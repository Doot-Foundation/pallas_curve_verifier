{
  "language": "Solidity",
  "sources": {
    "contracts/CORE_FieldsVerification.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./kimchi/Poseidon.sol\";\n\nerror InvalidPublicKey();\nerror StepSkipped();\n\n/**\n * @title PallasFieldsSignatureVerifier\n * @dev Verifies signatures over fields generated using mina-signer.\n */\n\ncontract PallasFieldsSignatureVerifier is Poseidon {\n    /// @notice Identifier for the type of verification.\n    uint8 constant TYPE_VERIFY_FIELDS = 2;\n\n    /// @notice Counter for tracking total number of field verification processes.\n    /// @dev Used as a unique ID. Incremented for each new verification process\n    uint256 public vfCounter = 0;\n\n    /// @notice Maps verification IDs to their creators' addresses\n    /// @dev Used for access control in cleanup operations\n    mapping(uint256 => address) public vfLifeCycleCreator;\n\n    /// @notice Maps verification IDs to their respective state structures\n    /// @dev Main storage for verification process states\n    mapping(uint256 => VerifyFieldsState) public vfLifeCycle;\n\n    /// @notice Maps verification IDs to their respective state structures compressed into bytes form.\n    /// Doesn't store intermediate states but only the important bits.\n    mapping(uint256 => bytes) public vfLifeCycleBytesCompressed;\n\n    /// @notice Ensures only the creator of a verification process can access it\n    /// @param vfId The verification process ID\n    modifier isVFCreator(uint256 vfId) {\n        if (msg.sender != vfLifeCycleCreator[vfId]) revert();\n        _;\n    }\n\n    /// @notice Ensures the verification ID exists\n    /// @param vfId The verification process ID to check\n    modifier isValidVFId(uint256 vfId) {\n        if (vfId >= vfCounter) revert();\n        _;\n    }\n\n    /// @notice Removes a verification process state from storage\n    /// @dev Can only be called by the creator of the verification process\n    /// @param vfId The ID of the verification process to clean up\n    function cleanupVFLifecycle(uint256 vfId) external isVFCreator(vfId) {\n        delete vfLifeCycle[vfId];\n    }\n\n    /// @notice Retrieves the complete state of a field verification process\n    /// @dev Returns a copy of the state, not a reference\n    /// @param vfId The ID of the verification process\n    /// @return state The complete verification state structure\n    function getVFState(\n        uint256 vfId\n    ) external view returns (VerifyFieldsState memory state) {\n        return vfLifeCycle[vfId];\n    }\n\n    /// @notice Retrieves the complete state of a verification process in bytes\n    /// @param vfId The ID of the verification process\n    /// @return state The complete verification state structure in bytes\n    function getVFStateBytesCompressed(\n        uint256 vfId\n    ) external view returns (bytes memory) {\n        return vfLifeCycleBytesCompressed[vfId];\n    }\n\n    /// @notice Decodes a compressed byte array into a VerifyFieldsStateCompressed struct\n    /// @param data The compressed bytes containing all VF state fields. Expected minimum length is 195 bytes\n    ///             plus additional bytes for the dynamic fields array\n    /// @return state The decoded VerifyFieldsStateCompressed struct containing:\n    ///               - verifyType (1 byte)\n    ///               - vfId (32 bytes)\n    ///               - mainnet flag (1 byte)\n    ///               - isValid flag (1 byte)\n    ///               - publicKey (x,y coordinates, 64 bytes)\n    ///               - signature (r,s values, 64 bytes)\n    ///               - messageHash (32 bytes)\n    ///               - prefix (constant string)\n    ///               - fields (dynamic uint256 array starting at byte 195)\n    function decodeVFStateBytesCompressed(\n        bytes calldata data\n    ) external pure returns (VerifyFieldsStateCompressed memory state) {\n        state.verifyType = uint8(data[0]);\n        state.vfId = uint256(bytes32(data[1:33]));\n        state.mainnet = (data[33] != 0);\n        state.isValid = (data[34] != 0);\n\n        uint256 x;\n        uint256 y;\n        uint256 r;\n        uint256 s;\n        uint256 messageHash;\n\n        assembly {\n            x := calldataload(add(data.offset, 35))\n            y := calldataload(add(data.offset, 67))\n            r := calldataload(add(data.offset, 99))\n            s := calldataload(add(data.offset, 131))\n            messageHash := calldataload(add(data.offset, 163))\n        }\n\n        state.publicKey.x = x;\n        state.publicKey.y = y;\n        state.signature.r = r;\n        state.signature.s = s;\n        state.messageHash = messageHash;\n        state.prefix = \"CodaSignature*******\";\n\n        state.fields = abi.decode(data[195:], (uint256[]));\n        return state;\n    }\n\n    /// @notice Validates if a point lies on the Pallas curve\n    /// @dev Checks if the point coordinates satisfy the curve equation y² = x³ + 5\n    /// @param point The point to validate with x and y coordinates\n    /// @return bool True if the point lies on the curve, false otherwise\n    function isValidPublicKey(Point memory point) public pure returns (bool) {\n        if (point.x >= FIELD_MODULUS || point.y >= FIELD_MODULUS) {\n            return false;\n        }\n\n        uint256 x2 = mulmod(point.x, point.x, FIELD_MODULUS);\n        uint256 lhs = mulmod(point.y, point.y, FIELD_MODULUS);\n        return\n            lhs == addmod(mulmod(x2, point.x, FIELD_MODULUS), 5, FIELD_MODULUS);\n    }\n\n    /// @notice Zero step - Input assignment.\n    /// ==================================================\n    /// @param publicKey The public key point (x,y)\n    /// @param signature Contains r (x-coordinate) and s (scalar)\n    /// @param fields Array of field elements to verify\n    /// @param network Network identifier (mainnet/testnet).\n    /// Note for _network : It doesn't matter what we use since mina-signer uses 'testnet' regardless\n    /// of the network set.\n    function step_0_VF_assignValues(\n        Point calldata publicKey,\n        Signature calldata signature,\n        uint256[] calldata fields,\n        bool network\n    ) external returns (uint256) {\n        if (!isValidPublicKey(publicKey)) revert InvalidPublicKey();\n\n        uint256 toSetId = vfCounter++;\n\n        VerifyFieldsState storage toPush = vfLifeCycle[toSetId];\n        // Pack initialization in optimal order\n        toPush.atStep = 0;\n        toPush.init = true;\n        toPush.mainnet = network;\n        toPush.publicKey = publicKey;\n        toPush.signature = signature;\n        toPush.fields = fields;\n        toPush.prefix = \"CodaSignature*******\";\n\n        vfLifeCycleCreator[toSetId] = msg.sender;\n\n        return toSetId;\n    }\n\n    /// @notice Compute hash of the message with network prefix\n    /// ==================================================\n    /// Matches the first part of verify():\n    /// let e = hashMessage(message, pk, r, networkId);\n    /// Process:\n    /// 1. Convert message to HashInput format\n    /// 2. Append public key coordinates and signature.r\n    /// 3. Apply network prefix and hash\n    /// Order is critical: [message fields] + [pk.x, pk.y, sig.r]\n    /// @param vfId id\n    function step_1_VF(uint256 vfId) external isValidVFId(vfId) {\n        VerifyFieldsState storage current = vfLifeCycle[vfId];\n        if (current.atStep != 0) revert StepSkipped();\n        if (!current.init) revert(\"Not initialized\");\n\n        // Cache fields array to avoid multiple storage reads\n        uint256[] memory fields = current.fields;\n        Point memory publicKey = current.publicKey;\n\n        current.messageHash = hashMessage(\n            fields,\n            publicKey,\n            current.signature.r,\n            current.prefix\n        );\n        current.atStep = 1;\n    }\n\n    /// @notice Convert public key to curve point\n    /// ==================================================\n    /// From o1js: PublicKey.toGroup(publicKey)\n    /// This converts compressed public key format (x, isOdd)\n    /// to full curve point representation by:\n    /// 1. Computing y² = x³ + 5 (Pallas curve equation)\n    /// 2. Taking square root\n    /// 3. Selecting appropriate y value based on isOdd\n    function step_2_VF(uint256 vfId) external isValidVFId(vfId) {\n        VerifyFieldsState storage current = vfLifeCycle[vfId];\n        if (current.atStep != 1) revert StepSkipped();\n\n        // Cache public key to avoid multiple storage reads\n        uint256 pubKeyX = current.publicKey.x;\n        uint256 pubKeyY = current.publicKey.y;\n\n        current.pkInGroup = _defaultToGroup(\n            PointCompressed({x: pubKeyX, isOdd: (pubKeyY & 1 == 1)})\n        );\n        current.atStep = 2;\n    }\n\n    /// @notice Compute s*G where G is generator point\n    /// ==================================================\n    /// From o1js: scale(one, s)\n    /// Critical: Do not reduce scalar by SCALAR_MODULUS\n    /// Uses projective coordinates internally for efficiency\n    /// Must use exact generator point coordinates from o1js:\n    /// G.x = 1\n    /// G.y = 0x1b74b5a30a12937c53dfa9f06378ee548f655bd4333d477119cf7a23caed2abb\n    function step_3_VF(uint256 vfId) external isValidVFId(vfId) {\n        VerifyFieldsState storage current = vfLifeCycle[vfId];\n        if (current.atStep != 2) revert StepSkipped();\n\n        Point memory G = Point(G_X, G_Y);\n        current.sG = scalarMul(G, current.signature.s);\n        current.atStep = 3;\n    }\n\n    /// @notice Compute e*publicKey\n    /// ==================================================\n    /// From o1js: scale(Group.toProjective(pk), e)\n    /// where e is the message hash computed in step 1\n    /// Uses same scalar multiplication as s*G\n    /// Takes public key point from step 2\n    function step_4_VF(uint256 vfId) external isValidVFId(vfId) {\n        VerifyFieldsState storage current = vfLifeCycle[vfId];\n        if (current.atStep != 3) revert StepSkipped();\n\n        Point memory pkInGroup = current.pkInGroup;\n        uint256 messageHash = current.messageHash;\n\n        current.ePk = scalarMul(pkInGroup, messageHash);\n        current.atStep = 4;\n    }\n\n    /// @notice Compute R = sG - ePk\n    /// ==================================================\n    /// From o1js: sub(scale(one, s), scale(Group.toProjective(pk), e))\n    /// Implemented as point addition with negated ePk\n    /// Point negation on Pallas: (x, -y)\n    /// R will be used for final verification\n    function step_5_VF(uint256 vfId) external isValidVFId(vfId) {\n        VerifyFieldsState storage current = vfLifeCycle[vfId];\n        if (current.atStep != 4) revert StepSkipped();\n\n        Point memory sG = current.sG;\n        Point memory ePk = current.ePk;\n\n        current.R = addPoints(sG, Point(ePk.x, FIELD_MODULUS - ePk.y));\n        current.atStep = 5;\n    }\n\n    /// @notice Final signature verification\n    /// ==================================================\n    /// From o1js:\n    /// let { x: rx, y: ry } = Group.fromProjective(R);\n    /// return Field.isEven(ry) && Field.equal(rx, r);\n    /// Two conditions must be met:\n    /// 1. R.x equals signature.r\n    /// 2. R.y is even\n    /// Returns final verification result\n    function step_6_VF(uint256 vfId) external isValidVFId(vfId) returns (bool) {\n        VerifyFieldsState storage current = vfLifeCycle[vfId];\n        if (current.atStep != 5) revert StepSkipped();\n\n        // Cache values and compute in memory\n        Point memory R = current.R;\n        uint256 sigR = current.signature.r;\n\n        current.isValid = (R.x == sigR) && (R.y & 1 == 0);\n        current.atStep = 6;\n\n        bytes memory stateBytesCompressed = packVerifyFieldsStateCompressed(\n            current,\n            vfId\n        );\n        vfLifeCycleBytesCompressed[vfId] = stateBytesCompressed;\n\n        return current.isValid;\n    }\n\n    /// @notice Packs a VerifyFieldsState into a compressed bytes format for efficient storage\n    /// @dev Combines fixed-length and dynamic data using abi.encodePacked and abi.encode\n    /// @param state The VerifyFieldsState to be compressed\n    /// @param vfId The unique identifier for this verification state\n    /// @return bytes The packed binary representation of the state\n    function packVerifyFieldsStateCompressed(\n        VerifyFieldsState memory state,\n        uint256 vfId\n    ) public pure returns (bytes memory) {\n        bytes memory fixedData = abi.encodePacked(\n            TYPE_VERIFY_FIELDS,\n            vfId,\n            state.mainnet,\n            state.isValid,\n            state.publicKey.x,\n            state.publicKey.y,\n            state.signature.r,\n            state.signature.s,\n            state.messageHash\n        );\n\n        return abi.encodePacked(fixedData, abi.encode(state.fields));\n    }\n\n    /// @notice Converts a string to its character array representation and computes its Poseidon hash\n    /// @dev Matches the behavior of CircuitString.from(str).hash() from o1js\n    /// Process:\n    /// 1. Converts string to fixed-length character array\n    /// 2. Pads array with zeros if needed\n    /// 3. Computes Poseidon hash of the array\n    /// @param str The input string to convert and hash\n    /// @return uint256[] Array of character values, padded to DEFAULT_STRING_LENGTH\n    /// @return uint256 Poseidon hash of the character array\n    function fromStringToHash(\n        string memory str\n    ) public view returns (uint256[] memory, uint256) {\n        bytes memory strBytes = bytes(str);\n        require(\n            strBytes.length <= DEFAULT_STRING_LENGTH,\n            \"CircuitString.fromString: input string exceeds max length!\"\n        );\n\n        uint256[] memory charValues = new uint256[](DEFAULT_STRING_LENGTH);\n\n        // Convert string characters to their numeric values\n        for (uint i = 0; i < strBytes.length; i++) {\n            charValues[i] = uint256(uint8(strBytes[i]));\n        }\n        // Pad remaining slots with zeros\n        for (uint i = strBytes.length; i < DEFAULT_STRING_LENGTH; i++) {\n            charValues[i] = 0;\n        }\n\n        uint256 charHash = poseidonHash(charValues);\n        return (charValues, charHash);\n    }\n\n    /// @notice Converts a compressed point to its full curve point representation\n    /// @dev Implements point decompression for Pallas curve (y² = x³ + 5)\n    /// Process:\n    /// 1. Keep x-coordinate from compressed point\n    /// 2. Calculate y² using curve equation (y² = x³ + 5)\n    /// 3. Compute square root to get y value\n    /// 4. Choose correct y value based on oddness flag\n    /// @param compressed The compressed point containing x-coordinate and oddness flag\n    /// @return Point Complete point with both x and y coordinates on Pallas curve\n    function _defaultToGroup(\n        PointCompressed memory compressed\n    ) internal view returns (Point memory) {\n        uint256 _x = compressed.x;\n\n        uint256 x2 = mulmod(_x, _x, FIELD_MODULUS);\n        uint256 y2 = addmod(mulmod(x2, _x, FIELD_MODULUS), BEQ, FIELD_MODULUS);\n\n        uint256 _y = sqrtmod(y2, FIELD_MODULUS);\n\n        if ((_y & 1 == 1) != compressed.isOdd) {\n            _y = FIELD_MODULUS - _y;\n        }\n\n        return Point({x: _x, y: _y});\n    }\n}\n"
    },
    "contracts/kimchi/PallasConstants.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract PallasConstants {\n    // Poseidon parameters matching poseidonParamsKimchiFp\n    uint256 internal constant POSEIDON_FULL_ROUNDS = 55;\n    uint256 internal constant POSEIDON_STATE_SIZE = 3;\n    uint256 internal constant POSEIDON_RATE = 2;\n    uint256 internal constant POSEIDON_POWER = 7;\n    bool internal constant POSEIDON_HAS_INITIAL_ROUND_CONSTANT = false;\n\n    uint256[3][3] internal mdsMatrix = [\n        [\n            12035446894107573964500871153637039653510326950134440362813193268448863222019,\n            25461374787957152039031444204194007219326765802730624564074257060397341542093,\n            27667907157110496066452777015908813333407980290333709698851344970789663080149\n        ],\n        [\n            4491931056866994439025447213644536587424785196363427220456343191847333476930,\n            14743631939509747387607291926699970421064627808101543132147270746750887019919,\n            9448400033389617131295304336481030167723486090288313334230651810071857784477\n        ],\n        [\n            10525578725509990281643336361904863911009900817790387635342941550657754064843,\n            27437632000253211280915908546961303399777448677029255413769125486614773776695,\n            27566319851776897085443681456689352477426926500749993803132851225169606086988\n        ]\n    ];\n\n    uint256[3][55] internal roundConstants = [\n        [\n            21155079691556475130150866428468322463125560312786319980770950159250751855431,\n            16883442198399350202652499677723930673110172289234921799701652810789093522349,\n            17030687036425314703519085065002231920937594822150793091243263847382891822670\n        ],\n        [\n            25216718237129482752721276445368692059997901880654047883630276346421457427360,\n            9054264347380455706540423067244764093107767235485930776517975315876127782582,\n            26439087121446593160953570192891907825526260324480347638727375735543609856888\n        ],\n        [\n            15251000790817261169639394496851831733819930596125214313084182526610855787494,\n            10861916012597714684433535077722887124099023163589869801449218212493070551767,\n            18597653523270601187312528478986388028263730767495975370566527202946430104139\n        ],\n        [\n            15831416454198644276563319006805490049460322229057756462580029181847589006611,\n            15171856919255965617705854914448645702014039524159471542852132430360867202292,\n            15488495958879593647482715143904752785889816789652405888927117106448507625751\n        ],\n        [\n            19039802679983063488134304670998725949842655199289961967801223969839823940152,\n            4720101937153217036737330058775388037616286510783561045464678919473230044408,\n            10226318327254973427513859412126640040910264416718766418164893837597674300190\n        ],\n        [\n            20878756131129218406920515859235137275859844638301967889441262030146031838819,\n            7178475685651744631172532830973371642652029385893667810726019303466125436953,\n            1996970955918516145107673266490486752153434673064635795711751450164177339618\n        ],\n        [\n            15205545916434157464929420145756897321482314798910153575340430817222504672630,\n            25660296961552699573824264215804279051322332899472350724416657386062327210698,\n            13842611741937412200312851417353455040950878279339067816479233688850376089318\n        ],\n        [\n            1383799642177300432144836486981606294838630135265094078921115713566691160459,\n            1135532281155277588005319334542025976079676424839948500020664227027300010929,\n            4384117336930380014868572224801371377488688194169758696438185377724744869360\n        ],\n        [\n            21725577575710270071808882335900370909424604447083353471892004026180492193649,\n            676128913284806802699862508051022306366147359505124346651466289788974059668,\n            25186611339598418732666781049829183886812651492845008333418424746493100589207\n        ],\n        [\n            10402240124664763733060094237696964473609580414190944671778761753887884341073,\n            11918307118590866200687906627767559273324023585642003803337447146531313172441,\n            16895677254395661024186292503536662354181715337630376909778003268311296637301\n        ],\n        [\n            23818602699032741669874498456696325705498383130221297580399035778119213224810,\n            4285193711150023248690088154344086684336247475445482883105661485741762600154,\n            19133204443389422404056150665863951250222934590192266371578950735825153238612\n        ],\n        [\n            5515589673266504033533906836494002702866463791762187140099560583198974233395,\n            11830435563729472715615302060564876527985621376031612798386367965451821182352,\n            7510711479224915247011074129666445216001563200717943545636462819681638560128\n        ],\n        [\n            24694843201907722940091503626731830056550128225297370217610328578733387733444,\n            27361655066973784653563425664091383058914302579694897188019422193564924110528,\n            21606788186194534241166833954371013788633495786419718955480491478044413102713\n        ],\n        [\n            19934060063390905409309407607814787335159021816537006003398035237707924006757,\n            8495813630060004961768092461554180468161254914257386012937942498774724649553,\n            27524960680529762202005330464726908693944660961000958842417927307941561848461\n        ],\n        [\n            15178481650950399259757805400615635703086255035073919114667254549690862896985,\n            16164780354695672259791105197274509251141405713012804937107314962551600380870,\n            10529167793600778056702353412758954281652843049850979705476598375597148191979\n        ],\n        [\n            721141070179074082553302896292167103755384741083338957818644728290501449040,\n            22044408985956234023934090378372374883099115753118261312473550998188148912041,\n            27068254103241989852888872162525066148367014691482601147536314217249046186315\n        ],\n        [\n            3880429241956357176819112098792744584376727450211873998699580893624868748961,\n            17387097125522937623262508065966749501583017524609697127088211568136333655623,\n            6256814421247770895467770393029354017922744712896100913895513234184920631289\n        ],\n        [\n            2942627347777337187690939671601251987500285937340386328746818861972711408579,\n            24031654937764287280548628128490074801809101323243546313826173430897408945397,\n            14401457902976567713827506689641442844921449636054278900045849050301331732143\n        ],\n        [\n            20170632877385406450742199836933900257692624353889848352407590794211839130727,\n            24056496193857444725324410428861722338174099794084586764867109123681727290181,\n            11257913009612703357266904349759250619633397075667824800196659858304604714965\n        ],\n        [\n            22228158921984425749199071461510152694025757871561406897041788037116931009246,\n            9152163378317846541430311327336774331416267016980485920222768197583559318682,\n            13906695403538884432896105059360907560653506400343268230130536740148070289175\n        ],\n        [\n            7220714562509721437034241786731185291972496952091254931195414855962344025067,\n            27608867305903811397208862801981345878179337369367554478205559689592889691927,\n            13288465747219756218882697408422850918209170830515545272152965967042670763153\n        ],\n        [\n            8251343892709140154567051772980662609566359215743613773155065627504813327653,\n            22035238365102171608166944627493632660244312563934708756134297161332908879090,\n            13560937766273321037807329177749403409731524715067067740487246745322577571823\n        ],\n        [\n            21652518608959234550262559135285358020552897349934571164032339186996805408040,\n            22479086963324173427634460342145551255011746993910136574926173581069603086891,\n            13676501958531751140966255121288182631772843001727158043704693838707387130095\n        ],\n        [\n            5680310394102577950568930199056707827608275306479994663197187031893244826674,\n            25125360450906166639190392763071557410047335755341060350879819485506243289998,\n            22659254028501616785029594492374243581602744364859762239504348429834224676676\n        ],\n        [\n            23101411405087512171421838856759448177512679869882987631073569441496722536782,\n            24149774013240355952057123660656464942409328637280437515964899830988178868108,\n            5782097512368226173095183217893826020351125522160843964147125728530147423065\n        ],\n        [\n            13540762114500083869920564649399977644344247485313990448129838910231204868111,\n            20421637734328811337527547703833013277831804985438407401987624070721139913982,\n            7742664118615900772129122541139124149525273579639574972380600206383923500701\n        ],\n        [\n            1109643801053963021778418773196543643970146666329661268825691230294798976318,\n            16580663920817053843121063692728699890952505074386761779275436996241901223840,\n            14638514680222429058240285918830106208025229459346033470787111294847121792366\n        ],\n        [\n            17080385857812672649489217965285727739557573467014392822992021264701563205891,\n            26176268111736737558502775993925696791974738793095023824029827577569530708665,\n            4382756253392449071896813428140986330161215829425086284611219278674857536001\n        ],\n        [\n            13934033814940585315406666445960471293638427404971553891617533231178815348902,\n            27054912732979753314774418228399230433963143177662848084045249524271046173121,\n            28916070403698593376490976676534962592542013020010643734621202484860041243391\n        ],\n        [\n            24820015636966360150164458094894587765384135259446295278101998130934963922381,\n            7969535238488580655870884015145760954416088335296905520306227531221721881868,\n            7690547696740080985104189563436871930607055124031711216224219523236060212249\n        ],\n        [\n            9712576468091272384496248353414290908377825697488757134833205246106605867289,\n            12148698031438398980683630141370402088785182722473169207262735228500190477924,\n            14359657643133476969781351728574842164124292705609900285041476162075031948227\n        ],\n        [\n            23563839965372067275137992801035780013422228997724286060975035719045352435470,\n            4184634822776323233231956802962638484057536837393405750680645555481330909086,\n            16249511905185772125762038789038193114431085603985079639889795722501216492487\n        ],\n        [\n            11001863048692031559800673473526311616702863826063550559568315794438941516621,\n            4702354107983530219070178410740869035350641284373933887080161024348425080464,\n            23751680507533064238793742311430343910720206725883441625894258483004979501613\n        ],\n        [\n            28670526516158451470169873496541739545860177757793329093045522432279094518766,\n            3568312993091537758218792253361873752799472566055209125947589819564395417072,\n            1819755756343439646550062754332039103654718693246396323207323333948654200950\n        ],\n        [\n            5372129954699791301953948907349887257752247843844511069896766784624930478273,\n            17512156688034945920605615850550150476471921176481039715733979181538491476080,\n            25777105342317622165159064911913148785971147228777677435200128966844208883059\n        ],\n        [\n            25350392006158741749134238306326265756085455157012701586003300872637887157982,\n            20096724945283767296886159120145376967480397366990493578897615204296873954844,\n            8063283381910110762785892100479219642751540456251198202214433355775540036851\n        ],\n        [\n            4393613870462297385565277757207010824900723217720226130342463666351557475823,\n            9874972555132910032057499689351411450892722671352476280351715757363137891038,\n            23590926474329902351439438151596866311245682682435235170001347511997242904868\n        ],\n        [\n            17723373371137275859467518615551278584842947963894791032296774955869958211070,\n            2350345015303336966039836492267992193191479606566494799781846958620636621159,\n            27755207882790211140683010581856487965587066971982625511152297537534623405016\n        ],\n        [\n            6584607987789185408123601849106260907671314994378225066806060862710814193906,\n            609759108847171587253578490536519506369136135254150754300671591987320319770,\n            28435187585965602110074342250910608316032945187476441868666714022529803033083\n        ],\n        [\n            16016664911651770663938916450245705908287192964254704641717751103464322455303,\n            17551273293154696089066968171579395800922204266630874071186322718903959339163,\n            20414195497994754529479032467015716938594722029047207834858832838081413050198\n        ],\n        [\n            19773307918850685463180290966774465805537520595602496529624568184993487593855,\n            24598603838812162820757838364185126333280131847747737533989799467867231166980,\n            11040972566103463398651864390163813377135738019556270484707889323659789290225\n        ],\n        [\n            5189242080957784038860188184443287562488963023922086723850863987437818393811,\n            1435203288979376557721239239445613396009633263160237764653161500252258220144,\n            13066591163578079667911016543985168493088721636164837520689376346534152547210\n        ],\n        [\n            17345901407013599418148210465150865782628422047458024807490502489711252831342,\n            22139633362249671900128029132387275539363684188353969065288495002671733200348,\n            1061056418502836172283188490483332922126033656372467737207927075184389487061\n        ],\n        [\n            10241738906190857416046229928455551829189196941239601756375665129874835232299,\n            27808033332417845112292408673209999320983657696373938259351951416571545364415,\n            18820154989873674261497645724903918046694142479240549687085662625471577737140\n        ],\n        [\n            7983688435214640842673294735439196010654951226956101271763849527529940619307,\n            17067928657801807648925755556866676899145460770352731818062909643149568271566,\n            24472070825156236829515738091791182856425635433388202153358580534810244942762\n        ],\n        [\n            25752201169361795911258625731016717414310986450004737514595241038036936283227,\n            26041505376284666160132119888949817249574689146924196064963008712979256107535,\n            23977050489096115210391718599021827780049209314283111721864956071820102846008\n        ],\n        [\n            26678257097278788410676026718736087312816016749016738933942134600725962413805,\n            10480026985951498884090911619636977502506079971893083605102044931823547311729,\n            21126631300593007055117122830961273871167754554670317425822083333557535463396\n        ],\n        [\n            1564862894215434177641156287699106659379648851457681469848362532131406827573,\n            13247162472821152334486419054854847522301612781818744556576865965657773174584,\n            8673615954922496961704442777870253767001276027366984739283715623634850885984\n        ],\n        [\n            2794525076937490807476666942602262298677291735723129868457629508555429470085,\n            4656175953888995612264371467596648522808911819700660048695373348629527757049,\n            23221574237857660318443567292601561932489621919104226163978909845174616477329\n        ],\n        [\n            1878392460078272317716114458784636517603142716091316893054365153068227117145,\n            2370412714505757731457251173604396662292063533194555369091306667486647634097,\n            17409784861870189930766639925394191888667317762328427589153989811980152373276\n        ],\n        [\n            25869136641898166514111941708608048269584233242773814014385564101168774293194,\n            11361209360311194794795494027949518465383235799633128250259863567683341091323,\n            14913258820718821235077379851098720071902170702113538811112331615559409988569\n        ],\n        [\n            12957012022018304419868287033513141736995211906682903915897515954290678373899,\n            17128889547450684566010972445328859295804027707361763477802050112063630550300,\n            23329219085372232771288306767242735245018143857623151155581182779769305489903\n        ],\n        [\n            1607741027962933685476527275858938699728586794398382348454736018784568853937,\n            2611953825405141009309433982109911976923326848135736099261873796908057448476,\n            7372230383134982628913227482618052530364724821976589156840317933676130378411\n        ],\n        [\n            20203606758501212620842735123770014952499754751430660463060696990317556818571,\n            4678361398979174017885631008335559529633853759463947250620930343087749944307,\n            27176462634198471376002287271754121925750749676999036165457559387195124025594\n        ],\n        [\n            6361981813552614697928697527332318530502852015189048838072565811230204474643,\n            13815234633287489023151647353581705241145927054858922281829444557905946323248,\n            10888828634279127981352133512429657747610298502219125571406085952954136470354\n        ]\n    ];\n}\n"
    },
    "contracts/kimchi/PallasCurve.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// import \"./PallasConstants.sol\";\nimport \"../PallasTypes.sol\";\nimport \"hardhat/console.sol\";\n\n/**\n * @title PallasCurve\n * @dev Implementation of Pallas curve operations\n */\ncontract PallasCurve is PallasTypes {\n    /// @notice Field modulus for Pallas curve\n    uint256 public constant FIELD_MODULUS =\n        0x40000000000000000000000000000000224698fc094cf91b992d30ed00000001;\n\n    /// @notice Scalar field modulus for Pallas curve\n    uint256 public constant SCALAR_MODULUS =\n        0x40000000000000000000000000224698fc0994a8dd8c46eb2100000001;\n\n    /// @notice Curve equation constant (B) where y² = x³ + B\n    uint256 public constant BEQ = 5;\n\n    /// @notice Default signature prefix for testnet\n    string public constant SIGNATURE_PREFIX = \"CodaSignature*******\";\n\n    /// @notice Signature prefix for mainnet\n    string public constant MAINNET_SIGNATURE_PREFIX = \"MinaSignatureMainnet\";\n\n    /// @notice Default length for string operations\n    uint256 public constant DEFAULT_STRING_LENGTH = 128;\n\n    /// @notice Generator point x-coordinate\n    uint256 public constant G_X = 1;\n\n    /// @notice Generator point y-coordinate\n    uint256 public constant G_Y =\n        0x1b74b5a30a12937c53dfa9f06378ee548f655bd4333d477119cf7a23caed2abb;\n\n    /// @notice Performs modular addition\n    /// @dev Wrapper around Solidity's addmod\n    /// @param x First operand\n    /// @param y Second operand\n    /// @param k Modulus\n    /// @return uint256 Result of (x + y) mod k\n    function add(uint x, uint y, uint k) internal pure returns (uint256) {\n        return addmod(x, y, k);\n    }\n\n    /// @notice Performs modular multiplication\n    /// @dev Wrapper around Solidity's mulmod\n    /// @param x First operand\n    /// @param y Second operand\n    /// @param k Modulus\n    /// @return uint256 Result of (x * y) mod k\n    function mul(uint x, uint y, uint k) internal pure returns (uint256) {\n        return mulmod(x, y, k);\n    }\n\n    /// @notice Computes modular multiplicative inverse\n    /// @dev Implements extended Euclidean algorithm for FIELD_MODULUS\n    /// @param a Value to invert\n    /// @return uint256 Modular multiplicative inverse of a\n    function invmod(uint256 a) internal pure returns (uint256) {\n        if (a == 0) revert(\"Cannot invert 0\");\n\n        uint256 t = 0;\n        uint256 newt = 1;\n        uint256 r = FIELD_MODULUS;\n        uint256 newr = a;\n        uint256 quotient;\n        uint256 temp;\n\n        unchecked {\n            while (newr != 0) {\n                quotient = r / newr;\n\n                temp = t;\n                t = newt;\n                newt = temp - quotient * newt;\n\n                temp = r;\n                r = newr;\n                newr = temp - quotient * newr;\n            }\n\n            if (t > FIELD_MODULUS) {\n                t += FIELD_MODULUS;\n            }\n        }\n        return t;\n    }\n\n    /// @notice Performs modular exponentiation\n    /// @dev Uses precompiled contract at address 0x05\n    /// @param base Base value\n    /// @param exponent Exponent value\n    /// @param modulus Modulus for operation\n    /// @return result Result of base^exponent mod modulus\n    function modExp(\n        uint256 base,\n        uint256 exponent,\n        uint256 modulus\n    ) internal view returns (uint256 result) {\n        assembly {\n            // Free memory pointer\n            let p := mload(0x40)\n\n            // Store length of base, exponent and modulus\n            mstore(p, 0x20)\n            mstore(add(p, 0x20), 0x20)\n            mstore(add(p, 0x40), 0x20)\n\n            // Store base, exponent and modulus\n            mstore(add(p, 0x60), base)\n            mstore(add(p, 0x80), exponent)\n            mstore(add(p, 0xa0), modulus)\n\n            // Call precompiled contract for modular exponentiation\n            if iszero(staticcall(gas(), 0x05, p, 0xc0, p, 0x20)) {\n                revert(0, 0)\n            }\n\n            result := mload(p)\n        }\n    }\n\n    /// @notice Computes modular square root\n    /// @dev Implements Tonelli-Shanks algorithm for prime modulus\n    /// @param n Value to find square root of\n    /// @param p Modulus (must be prime)\n    /// @return uint256 Modular square root of n\n    function sqrtmod(uint256 n, uint256 p) internal view returns (uint256) {\n        if (n == 0) return 0;\n\n        // Calculate Q and M where p - 1 = Q * 2^M and Q is odd\n        uint256 Q = p - 1;\n        uint256 M = 0;\n        while (Q % 2 == 0) {\n            Q /= 2;\n            M++;\n        }\n\n        // Find a non-residue z\n        uint256 z = 2;\n        while (true) {\n            if (modExp(z, (p - 1) / 2, p) == p - 1) break; // Found a non-residue\n            z++;\n        }\n\n        uint256 c = modExp(z, Q, p);\n        uint256 t = modExp(n, Q >> 1, p); // n^((Q-1)/2)\n        uint256 R = mulmod(t, n, p); // n^((Q+1)/2)\n        t = mulmod(t, R, p); // n^Q\n\n        while (t != 1) {\n            uint256 i = 0;\n            uint256 s = t;\n            while (s != 1 && i < M) {\n                s = mulmod(s, s, p);\n                i++;\n            }\n            require(i < M, \"Square root does not exist\");\n\n            uint256 b = c;\n            for (uint256 j = 0; j < M - i - 1; j++) {\n                b = mulmod(b, b, p);\n            }\n            M = i;\n            c = mulmod(b, b, p);\n            t = mulmod(t, c, p);\n            R = mulmod(R, b, p);\n        }\n\n        return R;\n    }\n\n    /// @notice Checks if a number is even\n    /// @dev Uses bitwise AND operation\n    /// @param x Number to check\n    /// @return bool True if number is even\n    function isEven(uint256 x) internal pure returns (bool) {\n        return (x & 1) == 0;\n    }\n\n    /// @notice Converts a point from affine to projective coordinates\n    /// @dev Used for efficient point operations. Returns (1:1:0) for point at infinity\n    /// @param p Point in affine coordinates (x,y)\n    /// @return ProjectivePoint Point in projective coordinates (X:Y:Z)\n    function toProjective(\n        Point memory p\n    ) internal pure returns (ProjectivePoint memory) {\n        if (p.x == 0 && p.y == 0) {\n            return ProjectivePoint(1, 1, 0); // Point at infinity\n        }\n        return ProjectivePoint(p.x, p.y, 1);\n    }\n\n    /// @notice Converts a point from projective to affine coordinates\n    /// @dev Performs modular inverse computation for Z coordinate\n    /// @param p Point in projective coordinates (X:Y:Z)\n    /// @return Point Point in affine coordinates (x,y)\n    function toAffine(\n        ProjectivePoint memory p\n    ) internal pure returns (Point memory) {\n        if (p.z == 0) {\n            return Point(0, 0); // Point at infinity\n        }\n\n        uint256 zinv = invmod(p.z);\n        uint256 zinv_squared = mulmod(zinv, zinv, FIELD_MODULUS);\n\n        return\n            Point(\n                mulmod(p.x, zinv_squared, FIELD_MODULUS),\n                mulmod(\n                    p.y,\n                    mulmod(zinv, zinv_squared, FIELD_MODULUS),\n                    FIELD_MODULUS\n                )\n            );\n    }\n\n    /// @notice Verifies if a point lies on the Pallas curve\n    /// @dev Checks if point satisfies y² = x³ + 5 (Pallas curve equation)\n    /// @param p Point to check\n    /// @return bool True if point is on curve\n    function isOnCurve(Point memory p) internal pure returns (bool) {\n        if (p.x >= FIELD_MODULUS || p.y >= FIELD_MODULUS) {\n            return false;\n        }\n\n        uint256 lhs = mulmod(p.y, p.y, FIELD_MODULUS);\n        uint256 x2 = mulmod(p.x, p.x, FIELD_MODULUS);\n        uint256 x3 = mulmod(x2, p.x, FIELD_MODULUS);\n        uint256 rhs = addmod(x3, BEQ, FIELD_MODULUS);\n\n        return lhs == rhs;\n    }\n\n    /// @notice Doubles a point in projective coordinates\n    /// @dev Specialized doubling formula for Pallas curve, matching o1js implementation\n    /// @param g Point to double in projective coordinates\n    /// @return ProjectivePoint Doubled point\n    function projectiveDouble(\n        ProjectivePoint memory g\n    ) internal pure returns (ProjectivePoint memory) {\n        if (g.z == 0) return g;\n        if (g.y == 0) revert(\"Cannot double point with y=0\");\n\n        unchecked {\n            // Cache x, y, z values\n            uint256 x = g.x;\n            uint256 y = g.y;\n            uint256 z = g.z;\n\n            // A = X1^2\n            uint256 A = mulmod(x, x, FIELD_MODULUS);\n            // B = Y1^2\n            uint256 B = mulmod(y, y, FIELD_MODULUS);\n            // C = B^2\n            uint256 C = mulmod(B, B, FIELD_MODULUS);\n\n            // Cache X1+B\n            uint256 xPlusB = addmod(x, B, FIELD_MODULUS);\n            // D = 2*((X1+B)^2-A-C)\n            uint256 D = mulmod(\n                2,\n                addmod(\n                    mulmod(xPlusB, xPlusB, FIELD_MODULUS),\n                    FIELD_MODULUS - addmod(A, C, FIELD_MODULUS),\n                    FIELD_MODULUS\n                ),\n                FIELD_MODULUS\n            );\n\n            // E = 3*A\n            uint256 E = mulmod(3, A, FIELD_MODULUS);\n            // F = E^2\n            uint256 F = mulmod(E, E, FIELD_MODULUS);\n\n            // Calculate final coordinates\n            uint256 X3 = addmod(\n                F,\n                FIELD_MODULUS - mulmod(2, D, FIELD_MODULUS),\n                FIELD_MODULUS\n            );\n            uint256 Y3 = addmod(\n                mulmod(\n                    E,\n                    addmod(D, FIELD_MODULUS - X3, FIELD_MODULUS),\n                    FIELD_MODULUS\n                ),\n                FIELD_MODULUS - mulmod(8, C, FIELD_MODULUS),\n                FIELD_MODULUS\n            );\n            uint256 Z3 = mulmod(2, mulmod(y, z, FIELD_MODULUS), FIELD_MODULUS);\n\n            return ProjectivePoint(X3, Y3, Z3);\n        }\n    }\n\n    /// @notice Adds two points in projective coordinates\n    /// @dev Implements complete addition formulas for Pallas curve, matching o1js behavior\n    /// @param g First point in projective coordinates\n    /// @param h Second point in projective coordinates\n    /// @return ProjectivePoint Sum of the points\n    function projectiveAdd(\n        ProjectivePoint memory g,\n        ProjectivePoint memory h\n    ) internal pure returns (ProjectivePoint memory) {\n        if (g.z == 0) return h;\n        if (h.z == 0) return g;\n\n        unchecked {\n            // Cache values\n            uint256 z1 = g.z;\n            uint256 z2 = h.z;\n\n            uint256 Z1Z1 = mulmod(z1, z1, FIELD_MODULUS);\n            uint256 Z2Z2 = mulmod(z2, z2, FIELD_MODULUS);\n            uint256 U1 = mulmod(g.x, Z2Z2, FIELD_MODULUS);\n            uint256 U2 = mulmod(h.x, Z1Z1, FIELD_MODULUS);\n            uint256 S1 = mulmod(\n                g.y,\n                mulmod(z2, Z2Z2, FIELD_MODULUS),\n                FIELD_MODULUS\n            );\n            uint256 S2 = mulmod(\n                h.y,\n                mulmod(z1, Z1Z1, FIELD_MODULUS),\n                FIELD_MODULUS\n            );\n            uint256 H = addmod(U2, FIELD_MODULUS - U1, FIELD_MODULUS);\n\n            if (H == 0) {\n                if (S1 == S2) {\n                    return projectiveDouble(g);\n                }\n                if (addmod(S1, S2, FIELD_MODULUS) == 0) {\n                    return ProjectivePoint(1, 1, 0);\n                }\n                revert(\"Invalid point addition\");\n            }\n\n            // Rest of calculations in one unchecked block for gas savings\n            uint256 I = mulmod(mulmod(H, H, FIELD_MODULUS), 4, FIELD_MODULUS);\n            uint256 J = mulmod(H, I, FIELD_MODULUS);\n            uint256 r = mulmod(\n                2,\n                addmod(S2, FIELD_MODULUS - S1, FIELD_MODULUS),\n                FIELD_MODULUS\n            );\n            uint256 V = mulmod(U1, I, FIELD_MODULUS);\n\n            uint256 X3 = addmod(\n                mulmod(r, r, FIELD_MODULUS),\n                FIELD_MODULUS -\n                    addmod(J, mulmod(2, V, FIELD_MODULUS), FIELD_MODULUS),\n                FIELD_MODULUS\n            );\n\n            uint256 Y3 = addmod(\n                mulmod(\n                    r,\n                    addmod(V, FIELD_MODULUS - X3, FIELD_MODULUS),\n                    FIELD_MODULUS\n                ),\n                FIELD_MODULUS -\n                    mulmod(2, mulmod(S1, J, FIELD_MODULUS), FIELD_MODULUS),\n                FIELD_MODULUS\n            );\n\n            uint256 Z3 = mulmod(\n                addmod(\n                    mulmod(\n                        addmod(z1, z2, FIELD_MODULUS),\n                        addmod(z1, z2, FIELD_MODULUS),\n                        FIELD_MODULUS\n                    ),\n                    FIELD_MODULUS - addmod(Z1Z1, Z2Z2, FIELD_MODULUS),\n                    FIELD_MODULUS\n                ),\n                H,\n                FIELD_MODULUS\n            );\n\n            return ProjectivePoint(X3, Y3, Z3);\n        }\n    }\n\n    /// @notice Adds two points in affine coordinates\n    /// @dev Converts to projective, adds, then converts back to affine\n    /// @param p1 First point in affine coordinates\n    /// @param p2 Second point in affine coordinates\n    /// @return Point Sum of the points in affine coordinates\n    function addPoints(\n        Point memory p1,\n        Point memory p2\n    ) internal pure returns (Point memory) {\n        ProjectivePoint memory g = toProjective(p1);\n        ProjectivePoint memory h = toProjective(p2);\n        ProjectivePoint memory r = projectiveAdd(g, h);\n        return toAffine(r);\n    }\n\n    /// @notice Performs scalar multiplication of a point\n    /// @dev Implements double-and-add algorithm, matching o1js behavior\n    /// @param p Base point to multiply\n    /// @param scalar Scalar value to multiply by\n    /// @return Point Result of scalar multiplication\n    function scalarMul(\n        Point memory p,\n        uint256 scalar\n    ) internal pure returns (Point memory) {\n        ProjectivePoint memory g = toProjective(p);\n        ProjectivePoint memory result = ProjectivePoint(1, 1, 0);\n        ProjectivePoint memory current = g;\n\n        // scalar = scalar % SCALAR_MODULUS;\n        while (scalar > 0) {\n            if (scalar & 1 == 1) {\n                result = projectiveAdd(result, current);\n            }\n            current = projectiveDouble(current);\n            scalar >>= 1;\n        }\n\n        return toAffine(result);\n    }\n}\n"
    },
    "contracts/kimchi/Poseidon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./PallasConstants.sol\";\nimport \"./PallasCurve.sol\";\n\n/**\n * @title PoseidonT3\n * @dev Implementation of Poseidon hash function for t = 3 (2 inputs)\n */\ncontract Poseidon is PallasCurve, PallasConstants {\n    uint256 internal constant CODA_PREFIX_FIELD =\n        240717916736854602989207148466022993262069182275;\n    uint256 internal constant MINA_PREFIX_FIELD =\n        664504924603203994814403132056773144791042910541;\n\n    /// @notice Computes x^7 mod FIELD_MODULUS\n    /// @dev Optimized power7 implementation matching o1js\n    /// @param x Base value\n    /// @return uint256 Result of x^7 mod FIELD_MODULUS\n    function power7(uint256 x) internal pure returns (uint256) {\n        uint256 x2 = mulmod(x, x, FIELD_MODULUS);\n        uint256 x3 = mulmod(x2, x, FIELD_MODULUS);\n        uint256 x6 = mulmod(x3, x3, FIELD_MODULUS);\n        return mulmod(x6, x, FIELD_MODULUS);\n    }\n\n    // Matrix and Round Constants\n    /// @notice Retrieves value from MDS matrix at specified position\n    /// @dev Used in the Poseidon permutation\n    /// @param row Row index of MDS matrix\n    /// @param col Column index of MDS matrix\n    /// @return uint256 Value at specified position\n    function getMdsValue(\n        uint256 row,\n        uint256 col\n    ) internal view returns (uint256) {\n        require(row < 3 && col < 3, \"Invalid MDS indices\");\n        return mdsMatrix[row][col];\n    }\n\n    /// @notice Retrieves round constant for specified round and position\n    /// @dev Used in the Poseidon permutation\n    /// @param round Round number\n    /// @param pos Position within the round\n    /// @return uint256 Round constant value\n    function getRoundConstant(\n        uint256 round,\n        uint256 pos\n    ) internal view returns (uint256) {\n        require(\n            round < POSEIDON_FULL_ROUNDS && pos < 3,\n            \"Invalid round constant indices\"\n        );\n        return roundConstants[round][pos];\n    }\n\n    /// @notice Performs matrix multiplication with MDS matrix\n    /// @dev Exactly matches o1js implementation\n    /// @param state Current state array\n    /// @return result Result of matrix multiplication\n    function mdsMultiply(\n        uint256[3] memory state\n    ) internal view returns (uint256[3] memory result) {\n        result[0] = addmod(\n            addmod(\n                mulmod(getMdsValue(0, 0), state[0], FIELD_MODULUS),\n                mulmod(getMdsValue(0, 1), state[1], FIELD_MODULUS),\n                FIELD_MODULUS\n            ),\n            mulmod(getMdsValue(0, 2), state[2], FIELD_MODULUS),\n            FIELD_MODULUS\n        );\n\n        result[1] = addmod(\n            addmod(\n                mulmod(getMdsValue(1, 0), state[0], FIELD_MODULUS),\n                mulmod(getMdsValue(1, 1), state[1], FIELD_MODULUS),\n                FIELD_MODULUS\n            ),\n            mulmod(getMdsValue(1, 2), state[2], FIELD_MODULUS),\n            FIELD_MODULUS\n        );\n\n        result[2] = addmod(\n            addmod(\n                mulmod(getMdsValue(2, 0), state[0], FIELD_MODULUS),\n                mulmod(getMdsValue(2, 1), state[1], FIELD_MODULUS),\n                FIELD_MODULUS\n            ),\n            mulmod(getMdsValue(2, 2), state[2], FIELD_MODULUS),\n            FIELD_MODULUS\n        );\n    }\n\n    // State Management\n    /// @notice Creates initial state array [0, 0, 0]\n    /// @dev Used to initialize Poseidon hash state\n    /// @return uint256[3] Initial state array\n    function initialState() internal pure returns (uint256[3] memory) {\n        return [uint256(0), uint256(0), uint256(0)];\n    }\n\n    /// @notice Performs the Poseidon permutation on a state\n    /// @dev Core permutation function for Poseidon hash\n    /// @param state Input state array\n    /// @return uint256[3] Permuted state\n    function poseidonPermutation(\n        uint256[3] memory state\n    ) internal view returns (uint256[3] memory) {\n        for (uint256 round = 0; round < POSEIDON_FULL_ROUNDS; round++) {\n            state[0] = power7(state[0]);\n            state[1] = power7(state[1]);\n            state[2] = power7(state[2]);\n\n            state = mdsMultiply(state);\n\n            state[0] = addmod(\n                state[0],\n                getRoundConstant(round, 0),\n                FIELD_MODULUS\n            );\n            state[1] = addmod(\n                state[1],\n                getRoundConstant(round, 1),\n                FIELD_MODULUS\n            );\n            state[2] = addmod(\n                state[2],\n                getRoundConstant(round, 2),\n                FIELD_MODULUS\n            );\n        }\n        return state;\n    }\n\n    /// @notice Updates state with input values\n    /// @dev Processes input in blocks of POSEIDON_RATE size\n    /// @param state Current state array\n    /// @param input Input values to process\n    /// @return uint256[3] Updated state\n    function update(\n        uint256[3] memory state,\n        uint256[] memory input\n    ) internal view returns (uint256[3] memory) {\n        if (input.length == 0) {\n            return poseidonPermutation(state);\n        }\n\n        uint256 blockIndex;\n        while (blockIndex < input.length) {\n            // Unrolled POSEIDON_RATE loop for common case of rate=2\n            if (blockIndex < input.length) {\n                state[0] = addmod(state[0], input[blockIndex], FIELD_MODULUS);\n            }\n            if (blockIndex + 1 < input.length) {\n                state[1] = addmod(\n                    state[1],\n                    input[blockIndex + 1],\n                    FIELD_MODULUS\n                );\n            }\n\n            state = poseidonPermutation(state);\n            blockIndex += POSEIDON_RATE;\n        }\n\n        return state;\n    }\n\n    /// String/Field Conversions\n    /// @notice Converts a string prefix to a field element\n    /// @dev Processes bytes in little-endian order, matching o1js implementation\n    /// @param prefix The string to convert\n    /// @return uint256 Field element representation of the prefix\n    function prefixToField(\n        string memory prefix\n    ) internal pure returns (uint256) {\n        bytes memory prefixBytes = bytes(prefix);\n        require(prefixBytes.length < 32, \"prefix too long\");\n\n        uint256 result = 0;\n        // Process in little-endian order (like o1js)\n        for (uint i = 0; i < 32; i++) {\n            if (i < prefixBytes.length) {\n                result |= uint256(uint8(prefixBytes[i])) << (i * 8);\n            }\n        }\n\n        return result % FIELD_MODULUS;\n    }\n\n    /// @notice Converts a string to a field element\n    /// @dev Processes bytes in little-endian order, similar to prefixToField\n    /// @param str The string to convert\n    /// @return uint256 Field element representation of the string\n    function stringToField(string memory str) internal pure returns (uint256) {\n        bytes memory strBytes = bytes(str);\n        require(strBytes.length < 32, \"prefix too long\");\n\n        uint256 result = 0;\n        // Process in little-endian order (like o1js)\n        for (uint i = 0; i < 32; i++) {\n            if (i < strBytes.length) {\n                result |= uint256(uint8(strBytes[i])) << (i * 8);\n            }\n            // zeros are handled implicitly\n        }\n\n        return result % FIELD_MODULUS;\n    }\n\n    // Main Hashing Functions\n    /// @notice Computes Poseidon hash of input array\n    /// @dev Main hashing function without prefix\n    /// @param input Array of field elements to hash\n    /// @return uint256 Resulting hash\n    function poseidonHash(\n        uint256[] memory input\n    ) public view returns (uint256) {\n        uint256[3] memory state = initialState();\n        state = update(state, input);\n\n        return state[0];\n    }\n\n    /// @notice Computes Poseidon hash with prefix\n    /// @dev Hashes prefix followed by input array\n    /// @param prefix String prefix to prepend\n    /// @param input Array of field elements to hash\n    /// @return uint256 Resulting hash\n    function poseidonHashWithPrefix(\n        string memory prefix,\n        uint256[] memory input\n    ) public view returns (uint256) {\n        uint256[3] memory state = initialState();\n\n        uint256[] memory prefixArray = new uint256[](1);\n        prefixArray[0] = prefixToField(prefix);\n        state = update(state, prefixArray);\n        state = update(state, input);\n\n        return state[0];\n    }\n\n    /// @notice Hashes message fields with public key and signature data\n    /// @dev Implements message hashing as specified in the signing scheme\n    /// @param fields Array of message fields\n    /// @param publicKey Public key point\n    /// @param r X-coordinate of signature point\n    /// @param prefix Network-specific prefix\n    /// @return uint256 Resulting message hash\n    function hashMessage(\n        uint256[] memory fields,\n        Point memory publicKey,\n        uint256 r,\n        string memory prefix\n    ) public view returns (uint256) {\n        // Pre-allocate array and copy fields\n        uint256[] memory fullInput = new uint256[](fields.length + 3);\n\n        assembly {\n            let length := mload(fields)\n            let srcPtr := add(fields, 0x20)\n            let destPtr := add(fullInput, 0x20)\n            // Copy fields array\n            for {\n                let i := 0\n            } lt(i, length) {\n                i := add(i, 1)\n            } {\n                mstore(\n                    add(destPtr, mul(i, 0x20)),\n                    mload(add(srcPtr, mul(i, 0x20)))\n                )\n            }\n            // Append public key and signature\n            mstore(add(destPtr, mul(length, 0x20)), mload(publicKey))\n            mstore(\n                add(destPtr, mul(add(length, 1), 0x20)),\n                mload(add(publicKey, 0x20))\n            )\n            mstore(add(destPtr, mul(add(length, 2), 0x20)), r)\n        }\n\n        // Use cached prefix value\n        uint256[3] memory state = initialState();\n        uint256[] memory prefixArray = new uint256[](1);\n        prefixArray[0] = keccak256(bytes(prefix)) ==\n            keccak256(bytes(\"MinaSignatureMainnet\"))\n            ? MINA_PREFIX_FIELD\n            : CODA_PREFIX_FIELD;\n\n        state = update(state, prefixArray);\n        state = update(state, fullInput);\n\n        return state[0];\n    }\n}\n"
    },
    "contracts/PallasTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title PallasTypes\n * @dev Common types used in Pallas operations\n */\ncontract PallasTypes {\n    /// @title Point Structure\n    /// @notice Represents a point on an elliptic curve with x and y coordinates\n    /// @dev Used for public key and signature operations\n    struct Point {\n        uint256 x;\n        uint256 y;\n    }\n\n    /// @title Compressed Point Structure\n    /// @notice Represents a compressed form of an elliptic curve point\n    /// @dev Uses x-coordinate and a boolean flag instead of full coordinates\n    struct PointCompressed {\n        uint256 x;\n        bool isOdd;\n    }\n\n    /// @title Digital Signature Structure\n    /// @notice Represents a digital signature with its components\n    /// @dev Used for cryptographic signature verification\n    struct Signature {\n        uint256 r;\n        uint256 s;\n    }\n\n    /// @title Projective Point Structure\n    /// @notice Represents a point in projective coordinates\n    /// @dev Used for efficient elliptic curve operations\n    struct ProjectivePoint {\n        uint256 x;\n        uint256 y;\n        uint256 z;\n    }\n\n    /// @title Verify Fields State Structure\n    /// @notice Holds the state for field array signature verification process\n    /// @dev Used to track the progress and store intermediate results during verification\n    struct VerifyFieldsState {\n        /// @notice Indicates if the state has been properly initialized\n        bool init;\n        /// @notice Network flag - true for mainnet, false for testnet\n        bool mainnet;\n        /// @notice Final verification result\n        bool isValid;\n        /// @notice Tracks the current step of verification (0-6)\n        uint8 atStep;\n        /// @notice The public key point (x,y) being verified against\n        Point publicKey;\n        /// @notice The signature containing r (x-coordinate) and s (scalar)\n        Signature signature;\n        /// @notice Hash of the fields array with prefix ('e' value)\n        uint256 messageHash;\n        /// @notice Public key converted to curve point format\n        Point pkInGroup;\n        /// @notice Result of scalar multiplication s*G\n        Point sG;\n        /// @notice Result of scalar multiplication e*pkInGroup\n        Point ePk;\n        /// @notice Final computed point R = sG - ePk\n        Point R;\n        /// @notice Network-specific prefix for message hashing\n        string prefix;\n        /// @notice Array of field elements to verify\n        uint256[] fields;\n    }\n\n    /// @title Verification Fields State Compressed Structure.\n    /// @notice Holds only the primary state for message signature verification process\n    struct VerifyFieldsStateCompressed {\n        /// @notice Indicates the type. 1 for Message, 2 for Fields. Helpful when reading\n        uint8 verifyType;\n        /// @notice The unique id\n        uint256 vfId;\n        /// @notice Network flag - true for mainnet, false for testnet\n        bool mainnet;\n        /// @notice Final verification result\n        bool isValid;\n        /// @notice The public key point (x,y) being verified against\n        Point publicKey;\n        /// @notice The signature containing r (x-coordinate) and s (scalar)\n        Signature signature;\n        /// @notice Hash of the fields array with prefix ('e' value)\n        uint256 messageHash;\n        /// @notice Network-specific prefix for message hashing\n        string prefix;\n        /// @notice Array of field elements to verify\n        uint256[] fields;\n    }\n\n    /// @title Verification Message State Structure\n    /// @notice Holds the state for message signature verification process\n    /// @dev Used to track the progress and store intermediate results during verification\n    struct VerifyMessageState {\n        /// @notice Indicates if the state has been properly initialized\n        bool init;\n        /// @notice Network flag - true for mainnet, false for testnet\n        bool mainnet;\n        /// @notice Final verification result\n        bool isValid;\n        /// @notice Tracks the current step of verification (0-6)\n        uint8 atStep;\n        /// @notice The public key point (x,y) being verified against\n        Point publicKey;\n        /// @notice The signature containing r (x-coordinate) and s (scalar)\n        Signature signature;\n        /// @notice Stores the computed hash of the message\n        uint256 messageHash;\n        /// @notice Public key converted to group form\n        Point pkInGroup;\n        /// @notice Result of scalar multiplication s*G\n        Point sG;\n        /// @notice Result of scalar multiplication e*pkInGroup\n        Point ePk;\n        /// @notice Final computed point R = sG - ePk\n        Point R;\n        /// @notice The message being verified\n        string message;\n        /// @notice Network-specific prefix for message hashing\n        string prefix;\n    }\n\n    /// @title Verification Message State Compressed Structure.\n    /// @notice Holds only the primary state for message signature verification process\n    struct VerifyMessageStateCompressed {\n        /// @notice Indicates the type. 1 for Message, 2 for Fields. Helpful when reading\n        uint8 verifyType;\n        /// @notice The unique id\n        uint256 vmId;\n        /// @notice Network flag - true for mainnet, false for testnet\n        bool mainnet;\n        /// @notice Final verification result\n        bool isValid;\n        /// @notice The public key point (x,y) being verified against\n        Point publicKey;\n        /// @notice The signature containing r (x-coordinate) and s (scalar)\n        Signature signature;\n        /// @notice Stores the computed hash of the message\n        uint256 messageHash;\n        /// @notice Network-specific prefix for message hashing\n        string prefix;\n        /// @notice The message being verified\n        string message;\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100000,
      "details": {
        "yul": true,
        "yulDetails": {
          "stackAllocation": true
        }
      }
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}