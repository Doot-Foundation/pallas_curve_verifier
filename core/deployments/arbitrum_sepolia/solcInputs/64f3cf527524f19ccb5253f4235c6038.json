{
  "language": "Solidity",
  "sources": {
    "contracts/bridge/PallasVerificationReceiever.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nstruct OptimizedPoint {\n    bytes32 x;\n    bytes32 y;\n}\n\nstruct OptimizedSignature {\n    bytes32 r;\n    bytes32 s;\n}\n\nstruct BatchedVerifications {\n    bytes32[] fieldsData;\n    bytes32[] messageHashes;\n    OptimizedSignature[] signatures;\n    OptimizedPoint[] keys;\n    bool[] isValid;\n}\n\nstruct OptimizedFieldsVerification {\n    uint256 vfId;\n    bool isValid;\n    bytes32[] fields;\n    OptimizedSignature signature;\n    OptimizedPoint publicKey;\n}\n\nstruct OptimizedMessageVerification {\n    uint256 vmId;\n    bool isValid;\n    bytes32 messageHash;\n    OptimizedSignature signature;\n    OptimizedPoint publicKey;\n}\n\nstruct OptimizedOriginalMessageVerification {\n    uint256 vmId;\n    bool isValid;\n    OptimizedSignature signature;\n    OptimizedPoint publicKey;\n    string message;\n}\n\ncontract PallasVerificationReceiever {\n    address public immutable trustedRemote;\n    uint16 public immutable srcChainId;\n    address public immutable lzEndpoint;\n\n    mapping(uint256 => OptimizedFieldsVerification) vfIdToData;\n    mapping(uint256 => OptimizedMessageVerification) vmIdToCompressedData; //Compressed since this deals with message hash.\n    mapping(uint256 => OptimizedOriginalMessageVerification) vmIdToData;\n\n    constructor(\n        address _trustedRemote,\n        uint16 _srcChainId,\n        address _lzEndpoint\n    ) {\n        trustedRemote = _trustedRemote;\n        srcChainId = _srcChainId;\n        lzEndpoint = _lzEndpoint;\n    }\n\n    modifier onlyLzEndpoint() {\n        require(msg.sender == lzEndpoint, \"Only LayerZero endpoint can call\");\n        _;\n    }\n    event FieldsVerificationReceived(\n        uint256 indexed vfId,\n        bool indexed isValid,\n        bytes32[] fields,\n        OptimizedSignature signature,\n        OptimizedPoint key\n    );\n\n    event MessageVerificationReceived(\n        uint256 indexed vmId,\n        bool indexed isValid,\n        bytes32 messageHash,\n        OptimizedSignature signature,\n        OptimizedPoint key\n    );\n\n    event OriginalMessageVerificationReceived(\n        uint256 indexed vmId,\n        bool indexed isValid,\n        string message,\n        OptimizedSignature signature,\n        OptimizedPoint key\n    );\n\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64,\n        bytes memory _payload\n    ) external onlyLzEndpoint {\n        require(_srcChainId == srcChainId, \"Invalid source chain\");\n        require(\n            _srcAddress.length == 20 &&\n                address(bytes20(_srcAddress)) == trustedRemote,\n            \"Invalid source address\"\n        );\n\n        uint8 typeId = uint8(_payload[0]);\n\n        if (typeId == 1) {\n            OptimizedFieldsVerification\n                memory verification = decodeSingleFieldsVerification(_payload);\n            vfIdToData[verification.vfId] = verification;\n            emit FieldsVerificationReceived(\n                verification.vfId,\n                verification.isValid,\n                verification.fields,\n                verification.signature,\n                verification.publicKey\n            );\n        } else if (typeId == 2) {\n            OptimizedMessageVerification\n                memory verification = decodeSingleMessageVerification(_payload);\n            vmIdToCompressedData[verification.vmId] = verification;\n            emit MessageVerificationReceived(\n                verification.vmId,\n                verification.isValid,\n                verification.messageHash,\n                verification.signature,\n                verification.publicKey\n            );\n        } else if (typeId == 3) {\n            OptimizedOriginalMessageVerification\n                memory verification = decodeSingleOriginalMessageVerification(\n                    _payload\n                );\n            vmIdToData[verification.vmId] = verification;\n            emit OriginalMessageVerificationReceived(\n                verification.vmId,\n                verification.isValid,\n                verification.message,\n                verification.signature,\n                verification.publicKey\n            );\n        } else {\n            revert(\"Invalid message type\");\n        }\n    }\n\n    function decodeSingleFieldsVerification(\n        bytes memory _payload\n    ) internal pure returns (OptimizedFieldsVerification memory) {\n        require(_payload[0] == 0x01, \"Invalid type for single fields\");\n\n        OptimizedFieldsVerification memory verification;\n        uint16 fieldsLength;\n\n        assembly {\n            let pointer := add(_payload, 1)\n\n            // Load vfId directly\n            mstore(add(verification, 0x20), mload(add(pointer, 0x00)))\n\n            // Load isValid\n            switch mload(add(pointer, 32))\n            case 0 {\n                mstore(add(verification, 0x40), 0)\n            }\n            default {\n                mstore(add(verification, 0x40), 1)\n            }\n\n            pointer := add(pointer, 33) // move past vfId and isValid\n\n            // Get fields length\n            fieldsLength := mload(pointer)\n            pointer := add(pointer, 32)\n\n            // Setup fields array\n            let fieldsPtr := add(verification, 0x60)\n            let newFieldsArr := mload(0x40) // get free memory pointer\n            mstore(0x40, add(add(newFieldsArr, 0x20), mul(fieldsLength, 0x20))) // update free memory pointer\n            mstore(newFieldsArr, fieldsLength) // store length\n            mstore(fieldsPtr, newFieldsArr) // store array pointer\n\n            // Copy fields\n            let destPtr := add(newFieldsArr, 0x20)\n            for {\n                let i := 0\n            } lt(i, fieldsLength) {\n                i := add(i, 1)\n            } {\n                mstore(add(destPtr, mul(i, 0x20)), mload(pointer))\n                pointer := add(pointer, 0x20)\n            }\n\n            // Load signature\n            let sig := add(verification, 0x80)\n            let sigPtr := mload(0x40)\n            mstore(0x40, add(sigPtr, 0x40))\n            mstore(sig, sigPtr)\n\n            mstore(sigPtr, mload(pointer)) // r\n            pointer := add(pointer, 32)\n            mstore(add(sigPtr, 32), mload(pointer)) // s\n            pointer := add(pointer, 32)\n\n            // Load public key\n            let pk := add(verification, 0xA0)\n            let pkPtr := mload(0x40)\n            mstore(0x40, add(pkPtr, 0x40))\n            mstore(pk, pkPtr)\n\n            mstore(pkPtr, mload(pointer)) // x\n            pointer := add(pointer, 32)\n            mstore(add(pkPtr, 32), mload(pointer)) // y\n        }\n\n        return verification;\n    }\n\n    // Decoder for single message verification\n    function decodeSingleMessageVerification(\n        bytes memory _payload\n    ) internal pure returns (OptimizedMessageVerification memory) {\n        require(_payload[0] == 0x02, \"Invalid type for single message\");\n\n        OptimizedMessageVerification memory verification;\n\n        assembly {\n            let pointer := add(_payload, 1)\n\n            // Load vmId directly\n            mstore(add(verification, 0x20), mload(add(pointer, 0x00)))\n\n            // Load isValid\n            switch mload(add(pointer, 32))\n            case 0 {\n                mstore(add(verification, 0x40), 0)\n            }\n            default {\n                mstore(add(verification, 0x40), 1)\n            }\n\n            pointer := add(pointer, 33) // move past vmId and isValid\n\n            // Load messageHash\n            mstore(add(verification, 0x60), mload(pointer))\n            pointer := add(pointer, 32)\n\n            // Load signature\n            let sig := add(verification, 0x80)\n            let sigPtr := mload(0x40)\n            mstore(0x40, add(sigPtr, 0x40))\n            mstore(sig, sigPtr)\n\n            mstore(sigPtr, mload(pointer))\n            pointer := add(pointer, 32)\n            mstore(add(sigPtr, 32), mload(pointer))\n            pointer := add(pointer, 32)\n\n            // Load public key\n            let pk := add(verification, 0xA0)\n            let pkPtr := mload(0x40)\n            mstore(0x40, add(pkPtr, 0x40))\n            mstore(pk, pkPtr)\n\n            mstore(pkPtr, mload(pointer))\n            pointer := add(pointer, 32)\n            mstore(add(pkPtr, 32), mload(pointer))\n        }\n\n        return verification;\n    }\n\n    // Add these new decoder functions\n    function decodeSingleOriginalMessageVerification(\n        bytes memory _payload\n    ) internal pure returns (OptimizedOriginalMessageVerification memory) {\n        require(_payload[0] == 0x03, \"Invalid type for original message\");\n\n        OptimizedOriginalMessageVerification memory verification;\n        uint256 messageLength;\n\n        assembly {\n            let pointer := add(_payload, 1)\n\n            // Load vmId directly\n            mstore(add(verification, 0x20), mload(add(pointer, 0x00)))\n\n            // Load isValid\n            switch mload(add(pointer, 32))\n            case 0 {\n                mstore(add(verification, 0x40), 0)\n            }\n            default {\n                mstore(add(verification, 0x40), 1)\n            }\n\n            pointer := add(pointer, 33) // move past vmId and isValid\n\n            // Get message length\n            messageLength := mload(pointer)\n            pointer := add(pointer, 32)\n        }\n\n        // Handle message separately from assembly\n        bytes memory messageBytes = new bytes(messageLength);\n        assembly {\n            let msgPtr := add(messageBytes, 32)\n            let payloadPtr := add(_payload, 66) // type(1) + vmId(32) + isValid(1) + length(32)\n\n            // Copy message bytes\n            for {\n                let i := 0\n            } lt(i, messageLength) {\n                i := add(i, 32)\n            } {\n                mstore(add(msgPtr, i), mload(add(payloadPtr, i)))\n            }\n            mstore(messageBytes, messageLength)\n        }\n        verification.message = string(messageBytes);\n\n        // Continue with signature and public key\n        assembly {\n            let pointer := add(add(_payload, 66), messageLength) // Start after message\n\n            // Load signature\n            let sig := add(verification, 0x60)\n            let sigPtr := mload(0x40)\n            mstore(0x40, add(sigPtr, 0x40))\n            mstore(sig, sigPtr)\n\n            mstore(sigPtr, mload(pointer))\n            pointer := add(pointer, 32)\n            mstore(add(sigPtr, 32), mload(pointer))\n            pointer := add(pointer, 32)\n\n            // Load public key\n            let pk := add(verification, 0x80)\n            let pkPtr := mload(0x40)\n            mstore(0x40, add(pkPtr, 0x40))\n            mstore(pk, pkPtr)\n\n            mstore(pkPtr, mload(pointer))\n            pointer := add(pointer, 32)\n            mstore(add(pkPtr, 32), mload(pointer))\n        }\n\n        return verification;\n    }\n}\n"
    },
    "contracts/CORE_FieldsVerification.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./kimchi/Poseidon.sol\";\n\nerror InvalidPublicKey();\nerror StepSkipped();\n\n/**\n * @title PallasFieldsSignatureVerifier\n * @dev Verifies signatures over fields generated using mina-signer.\n */\n\ncontract PallasFieldsSignatureVerifier is Poseidon {\n    /// @notice Identifier for the type of verification.\n    uint8 constant TYPE_VERIFY_FIELDS = 2;\n\n    /// @notice Counter for tracking total number of field verification processes.\n    /// @dev Used as a unique ID. Incremented for each new verification process\n    uint256 public vfCounter = 0;\n\n    /// @notice Maps verification IDs to their creators' addresses\n    /// @dev Used for access control in cleanup operations\n    mapping(uint256 => address) public vfLifeCycleCreator;\n\n    /// @notice Maps verification IDs to their respective state structures\n    /// @dev Main storage for verification process states\n    mapping(uint256 => VerifyFieldsState) public vfLifeCycle;\n\n    /// @notice Maps verification IDs to their respective state structures compressed into bytes form.\n    /// Doesn't store intermediate states but only the important bits.\n    mapping(uint256 => bytes) public vfLifeCycleBytesCompressed;\n\n    /// @notice Ensures only the creator of a verification process can access it\n    /// @param vfId The verification process ID\n    modifier isVFCreator(uint256 vfId) {\n        if (msg.sender != vfLifeCycleCreator[vfId]) revert();\n        _;\n    }\n\n    /// @notice Ensures the verification ID exists\n    /// @param vfId The verification process ID to check\n    modifier isValidVFId(uint256 vfId) {\n        if (vfId >= vfCounter) revert();\n        _;\n    }\n\n    /// @notice Removes a verification process state from storage\n    /// @dev Can only be called by the creator of the verification process\n    /// @param vfId The ID of the verification process to clean up\n    function cleanupVFLifecycle(uint256 vfId) external isVFCreator(vfId) {\n        delete vfLifeCycle[vfId];\n    }\n\n    /// @notice Retrieves the complete state of a field verification process\n    /// @dev Returns a copy of the state, not a reference\n    /// @param vfId The ID of the verification process\n    /// @return state The complete verification state structure\n    function getVFState(\n        uint256 vfId\n    ) external view returns (VerifyFieldsState memory state) {\n        return vfLifeCycle[vfId];\n    }\n\n    /// @notice Retrieves the complete state of a verification process in bytes\n    /// @param vfId The ID of the verification process\n    /// @return state The complete verification state structure in bytes\n    function getVFStateBytesCompressed(\n        uint256 vfId\n    ) external view returns (bytes memory) {\n        return vfLifeCycleBytesCompressed[vfId];\n    }\n\n    /// @notice Decodes a compressed byte array into a VerifyFieldsStateCompressed struct\n    /// @param data The compressed bytes containing all VF state fields. Expected minimum length is 195 bytes\n    ///             plus additional bytes for the dynamic fields array\n    /// @return state The decoded VerifyFieldsStateCompressed struct containing:\n    ///               - verifyType (1 byte)\n    ///               - vfId (32 bytes)\n    ///               - mainnet flag (1 byte)\n    ///               - isValid flag (1 byte)\n    ///               - publicKey (x,y coordinates, 64 bytes)\n    ///               - signature (r,s values, 64 bytes)\n    ///               - messageHash (32 bytes)\n    ///               - prefix (constant string)\n    ///               - fields (dynamic uint256 array starting at byte 195)\n    function decodeVFStateBytesCompressed(\n        bytes calldata data\n    ) external pure returns (VerifyFieldsStateCompressed memory state) {\n        state.verifyType = uint8(data[0]);\n        state.vfId = uint256(bytes32(data[1:33]));\n        state.mainnet = (data[33] != 0);\n        state.isValid = (data[34] != 0);\n\n        uint256 x;\n        uint256 y;\n        uint256 r;\n        uint256 s;\n        uint256 messageHash;\n\n        assembly {\n            x := calldataload(add(data.offset, 35))\n            y := calldataload(add(data.offset, 67))\n            r := calldataload(add(data.offset, 99))\n            s := calldataload(add(data.offset, 131))\n            messageHash := calldataload(add(data.offset, 163))\n        }\n\n        state.publicKey.x = x;\n        state.publicKey.y = y;\n        state.signature.r = r;\n        state.signature.s = s;\n        state.messageHash = messageHash;\n        state.prefix = \"CodaSignature*******\";\n\n        state.fields = abi.decode(data[195:], (uint256[]));\n        return state;\n    }\n\n    /// @notice Validates if a point lies on the Pallas curve\n    /// @dev Checks if the point coordinates satisfy the curve equation y² = x³ + 5\n    /// @param point The point to validate with x and y coordinates\n    /// @return bool True if the point lies on the curve, false otherwise\n    function isValidPublicKey(Point memory point) public pure returns (bool) {\n        if (point.x >= FIELD_MODULUS || point.y >= FIELD_MODULUS) {\n            return false;\n        }\n\n        uint256 x2 = mulmod(point.x, point.x, FIELD_MODULUS);\n        uint256 lhs = mulmod(point.y, point.y, FIELD_MODULUS);\n        return\n            lhs == addmod(mulmod(x2, point.x, FIELD_MODULUS), 5, FIELD_MODULUS);\n    }\n\n    /// @notice Zero step - Input assignment.\n    /// ==================================================\n    /// @param publicKey The public key point (x,y)\n    /// @param signature Contains r (x-coordinate) and s (scalar)\n    /// @param fields Array of field elements to verify\n    /// @param network Network identifier (mainnet/testnet).\n    /// Note for _network : It doesn't matter what we use since mina-signer uses 'testnet' regardless\n    /// of the network set.\n    function step_0_VF_assignValues(\n        Point calldata publicKey,\n        Signature calldata signature,\n        uint256[] calldata fields,\n        bool network\n    ) external returns (uint256) {\n        if (!isValidPublicKey(publicKey)) revert InvalidPublicKey();\n\n        uint256 toSetId = vfCounter++;\n\n        VerifyFieldsState storage toPush = vfLifeCycle[toSetId];\n        // Pack initialization in optimal order\n        toPush.atStep = 0;\n        toPush.init = true;\n        toPush.mainnet = network;\n        toPush.publicKey = publicKey;\n        toPush.signature = signature;\n        toPush.fields = fields;\n        toPush.prefix = \"CodaSignature*******\";\n\n        vfLifeCycleCreator[toSetId] = msg.sender;\n\n        return toSetId;\n    }\n\n    /// @notice Compute hash of the message with network prefix\n    /// ==================================================\n    /// Matches the first part of verify():\n    /// let e = hashMessage(message, pk, r, networkId);\n    /// Process:\n    /// 1. Convert message to HashInput format\n    /// 2. Append public key coordinates and signature.r\n    /// 3. Apply network prefix and hash\n    /// Order is critical: [message fields] + [pk.x, pk.y, sig.r]\n    /// @param vfId id\n    function step_1_VF(uint256 vfId) external isValidVFId(vfId) {\n        VerifyFieldsState storage current = vfLifeCycle[vfId];\n        if (current.atStep != 0) revert StepSkipped();\n        if (!current.init) revert(\"Not initialized\");\n\n        // Cache fields array to avoid multiple storage reads\n        uint256[] memory fields = current.fields;\n        Point memory publicKey = current.publicKey;\n\n        current.messageHash = hashMessage(\n            fields,\n            publicKey,\n            current.signature.r,\n            current.prefix\n        );\n        current.atStep = 1;\n    }\n\n    /// @notice Convert public key to curve point\n    /// ==================================================\n    /// From o1js: PublicKey.toGroup(publicKey)\n    /// This converts compressed public key format (x, isOdd)\n    /// to full curve point representation by:\n    /// 1. Computing y² = x³ + 5 (Pallas curve equation)\n    /// 2. Taking square root\n    /// 3. Selecting appropriate y value based on isOdd\n    function step_2_VF(uint256 vfId) external isValidVFId(vfId) {\n        VerifyFieldsState storage current = vfLifeCycle[vfId];\n        if (current.atStep != 1) revert StepSkipped();\n\n        // Cache public key to avoid multiple storage reads\n        uint256 pubKeyX = current.publicKey.x;\n        uint256 pubKeyY = current.publicKey.y;\n\n        current.pkInGroup = _defaultToGroup(\n            PointCompressed({x: pubKeyX, isOdd: (pubKeyY & 1 == 1)})\n        );\n        current.atStep = 2;\n    }\n\n    /// @notice Compute s*G where G is generator point\n    /// ==================================================\n    /// From o1js: scale(one, s)\n    /// Critical: Do not reduce scalar by SCALAR_MODULUS\n    /// Uses projective coordinates internally for efficiency\n    /// Must use exact generator point coordinates from o1js:\n    /// G.x = 1\n    /// G.y = 0x1b74b5a30a12937c53dfa9f06378ee548f655bd4333d477119cf7a23caed2abb\n    function step_3_VF(uint256 vfId) external isValidVFId(vfId) {\n        VerifyFieldsState storage current = vfLifeCycle[vfId];\n        if (current.atStep != 2) revert StepSkipped();\n\n        Point memory G = Point(G_X, G_Y);\n        current.sG = scalarMul(G, current.signature.s);\n        current.atStep = 3;\n    }\n\n    /// @notice Compute e*publicKey\n    /// ==================================================\n    /// From o1js: scale(Group.toProjective(pk), e)\n    /// where e is the message hash computed in step 1\n    /// Uses same scalar multiplication as s*G\n    /// Takes public key point from step 2\n    function step_4_VF(uint256 vfId) external isValidVFId(vfId) {\n        VerifyFieldsState storage current = vfLifeCycle[vfId];\n        if (current.atStep != 3) revert StepSkipped();\n\n        Point memory pkInGroup = current.pkInGroup;\n        uint256 messageHash = current.messageHash;\n\n        current.ePk = scalarMul(pkInGroup, messageHash);\n        current.atStep = 4;\n    }\n\n    /// @notice Compute R = sG - ePk\n    /// ==================================================\n    /// From o1js: sub(scale(one, s), scale(Group.toProjective(pk), e))\n    /// Implemented as point addition with negated ePk\n    /// Point negation on Pallas: (x, -y)\n    /// R will be used for final verification\n    function step_5_VF(uint256 vfId) external isValidVFId(vfId) {\n        VerifyFieldsState storage current = vfLifeCycle[vfId];\n        if (current.atStep != 4) revert StepSkipped();\n\n        Point memory sG = current.sG;\n        Point memory ePk = current.ePk;\n\n        current.R = addPoints(sG, Point(ePk.x, FIELD_MODULUS - ePk.y));\n        current.atStep = 5;\n    }\n\n    /// @notice Final signature verification\n    /// ==================================================\n    /// From o1js:\n    /// let { x: rx, y: ry } = Group.fromProjective(R);\n    /// return Field.isEven(ry) && Field.equal(rx, r);\n    /// Two conditions must be met:\n    /// 1. R.x equals signature.r\n    /// 2. R.y is even\n    /// Returns final verification result\n    function step_6_VF(uint256 vfId) external isValidVFId(vfId) returns (bool) {\n        VerifyFieldsState storage current = vfLifeCycle[vfId];\n        if (current.atStep != 5) revert StepSkipped();\n\n        // Cache values and compute in memory\n        Point memory R = current.R;\n        uint256 sigR = current.signature.r;\n\n        current.isValid = (R.x == sigR) && (R.y & 1 == 0);\n        current.atStep = 6;\n\n        bytes memory stateBytesCompressed = packVerifyFieldsStateCompressed(\n            current,\n            vfId\n        );\n        vfLifeCycleBytesCompressed[vfId] = stateBytesCompressed;\n\n        return current.isValid;\n    }\n\n    /// @notice Packs a VerifyFieldsState into a compressed bytes format for efficient storage\n    /// @dev Combines fixed-length and dynamic data using abi.encodePacked and abi.encode\n    /// @param state The VerifyFieldsState to be compressed\n    /// @param vfId The unique identifier for this verification state\n    /// @return bytes The packed binary representation of the state\n    function packVerifyFieldsStateCompressed(\n        VerifyFieldsState memory state,\n        uint256 vfId\n    ) public pure returns (bytes memory) {\n        bytes memory fixedData = abi.encodePacked(\n            TYPE_VERIFY_FIELDS,\n            vfId,\n            state.mainnet,\n            state.isValid,\n            state.publicKey.x,\n            state.publicKey.y,\n            state.signature.r,\n            state.signature.s,\n            state.messageHash\n        );\n\n        return abi.encodePacked(fixedData, abi.encode(state.fields));\n    }\n\n    /// @notice Converts a string to its character array representation and computes its Poseidon hash\n    /// @dev Matches the behavior of CircuitString.from(str).hash() from o1js\n    /// Process:\n    /// 1. Converts string to fixed-length character array\n    /// 2. Pads array with zeros if needed\n    /// 3. Computes Poseidon hash of the array\n    /// @param str The input string to convert and hash\n    /// @return uint256[] Array of character values, padded to DEFAULT_STRING_LENGTH\n    /// @return uint256 Poseidon hash of the character array\n    function fromStringToHash(\n        string memory str\n    ) public view returns (uint256[] memory, uint256) {\n        bytes memory strBytes = bytes(str);\n        require(\n            strBytes.length <= DEFAULT_STRING_LENGTH,\n            \"CircuitString.fromString: input string exceeds max length!\"\n        );\n\n        uint256[] memory charValues = new uint256[](DEFAULT_STRING_LENGTH);\n\n        // Convert string characters to their numeric values\n        for (uint i = 0; i < strBytes.length; i++) {\n            charValues[i] = uint256(uint8(strBytes[i]));\n        }\n        // Pad remaining slots with zeros\n        for (uint i = strBytes.length; i < DEFAULT_STRING_LENGTH; i++) {\n            charValues[i] = 0;\n        }\n\n        uint256 charHash = poseidonHash(charValues);\n        return (charValues, charHash);\n    }\n\n    /// @notice Converts a compressed point to its full curve point representation\n    /// @dev Implements point decompression for Pallas curve (y² = x³ + 5)\n    /// Process:\n    /// 1. Keep x-coordinate from compressed point\n    /// 2. Calculate y² using curve equation (y² = x³ + 5)\n    /// 3. Compute square root to get y value\n    /// 4. Choose correct y value based on oddness flag\n    /// @param compressed The compressed point containing x-coordinate and oddness flag\n    /// @return Point Complete point with both x and y coordinates on Pallas curve\n    function _defaultToGroup(\n        PointCompressed memory compressed\n    ) internal view returns (Point memory) {\n        uint256 _x = compressed.x;\n\n        uint256 x2 = mulmod(_x, _x, FIELD_MODULUS);\n        uint256 y2 = addmod(mulmod(x2, _x, FIELD_MODULUS), BEQ, FIELD_MODULUS);\n\n        uint256 _y = sqrtmod(y2, FIELD_MODULUS);\n\n        if ((_y & 1 == 1) != compressed.isOdd) {\n            _y = FIELD_MODULUS - _y;\n        }\n\n        return Point({x: _x, y: _y});\n    }\n}\n"
    },
    "contracts/CORE_MessageVerification.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./legacy/PoseidonLegacy.sol\";\n\nerror InvalidPublicKey();\nerror StepSkipped();\n\n/**\n * @title PallasMessageSignatureVerifier\n * @dev Verifies signatures over message generated using mina-signer.\n */\n\ncontract PallasMessageSignatureVerifier is PoseidonLegacy {\n    /// @notice Identifier for the type of verification.\n    uint8 constant TYPE_VERIFY_MESSAGE = 1;\n\n    /// @notice Counter for tracking total number of verification processes\n    /// @dev Used as a unique ID. Incremented for each new verification process\n    uint256 public vmCounter = 0;\n\n    /// @notice Maps verification IDs to their creators' addresses\n    /// @dev Used for access control in cleanup operations\n    mapping(uint256 => address) public vmLifeCycleCreator;\n\n    /// @notice Maps verification IDs to their respective state structures\n    /// @dev Main storage for verification process states\n    mapping(uint256 => VerifyMessageState) public vmLifeCycle;\n\n    /// @notice Maps verification IDs to their respective state structures compressed into bytes form.\n    /// Doesn't store intermediate states but only the important bits.\n    mapping(uint256 => bytes) public vmLifeCycleBytesCompressed;\n\n    /// @notice Ensures only the creator of a verification process can access it\n    /// @param vmId The verification process ID\n    modifier isVMCreator(uint256 vmId) {\n        if (msg.sender != vmLifeCycleCreator[vmId]) revert();\n        _;\n    }\n\n    /// @notice Ensures the verification ID exists\n    /// @param vmId The verification process ID to check\n    modifier isValidVMId(uint256 vmId) {\n        if (vmId >= vmCounter) revert();\n        _;\n    }\n\n    /// @notice Removes a verification process state from storage\n    /// @dev Can only be called by the creator of the verification process\n    /// @param vmId The ID of the verification process to clean up\n    function cleanupVMLifecycle(uint256 vmId) external isVMCreator(vmId) {\n        delete vmLifeCycle[vmId];\n    }\n\n    /// @notice Retrieves the complete state of a verification process\n    /// @dev Returns a copy of the state, not a reference\n    /// @param vmId The ID of the verification process\n    /// @return state The complete verification state structure\n    function getVMState(\n        uint256 vmId\n    ) external view returns (VerifyMessageState memory state) {\n        return vmLifeCycle[vmId];\n    }\n\n    /// @notice Retrieves the complete state of a verification process in bytes\n    /// @param vmId The ID of the verification process\n    /// @return state The complete verification state structure in bytes\n    function getVMStateBytesCompressed(\n        uint256 vmId\n    ) external view returns (bytes memory) {\n        return vmLifeCycleBytesCompressed[vmId];\n    }\n\n    /// @notice Decodes a compressed byte array into a VerifyMessageStateCompressed struct\n    /// @param data The compressed bytes containing all VM state fields. Expected minimum length is 195 bytes\n    ///             plus additional bytes for the dynamic message string\n    /// @return state The decoded VerifyMessageStateCompressed struct containing:\n    ///               - verifyType (1 byte)\n    ///               - vmId (32 bytes)\n    ///               - mainnet flag (1 byte)\n    ///               - isValid flag (1 byte)\n    ///               - publicKey (x,y coordinates, 64 bytes)\n    ///               - signature (r,s values, 64 bytes)\n    ///               - messageHash (32 bytes)\n    ///               - prefix (network-dependent string)\n    ///               - message (dynamic string starting at byte 195)\n    /// @dev The prefix is set conditionally based on the mainnet flag:\n    ///      - mainnet=true: \"MinaSignatureMainnet\"\n    ///      - mainnet=false: \"CodaSignature*******\"\n    function decodeVMStateBytesCompressed(\n        bytes calldata data\n    ) external pure returns (VerifyMessageStateCompressed memory state) {\n        state.verifyType = uint8(data[0]);\n        state.vmId = uint256(bytes32(data[1:33]));\n        state.mainnet = (data[33] != 0);\n        state.isValid = (data[34] != 0);\n\n        uint256 x;\n        uint256 y;\n        uint256 r;\n        uint256 s;\n        uint256 messageHash;\n\n        assembly {\n            // Load all values first\n            x := calldataload(add(data.offset, 35))\n            y := calldataload(add(data.offset, 67))\n            r := calldataload(add(data.offset, 99))\n            s := calldataload(add(data.offset, 131))\n            messageHash := calldataload(add(data.offset, 163))\n        }\n\n        // Then assign to struct fields\n        state.publicKey.x = x;\n        state.publicKey.y = y;\n        state.signature.r = r;\n        state.signature.s = s;\n        state.messageHash = messageHash;\n        state.prefix = state.mainnet\n            ? \"MinaSignatureMainnet\"\n            : \"CodaSignature*******\";\n\n        state.message = abi.decode(data[195:], (string));\n        return state;\n    }\n\n    /// @notice Validates if a point lies on the Pallas curve\n    /// @dev Checks if the point coordinates satisfy the curve equation y² = x³ + 5\n    /// @param point The point to validate with x and y coordinates\n    /// @return bool True if the point lies on the curve, false otherwise\n    function isValidPublicKey(Point memory point) public pure returns (bool) {\n        if (point.x >= FIELD_MODULUS || point.y >= FIELD_MODULUS) {\n            return false;\n        }\n\n        uint256 x2 = mulmod(point.x, point.x, FIELD_MODULUS);\n        uint256 lhs = mulmod(point.y, point.y, FIELD_MODULUS);\n        return\n            lhs == addmod(mulmod(x2, point.x, FIELD_MODULUS), 5, FIELD_MODULUS);\n    }\n\n    /// @notice Zero step - Input assignment for message verification\n    /// ==================================================\n    /// Initializes the verification state for a message signature\n    /// @param publicKey The public key point (x,y)\n    /// @param signature Contains r (x-coordinate) and s (scalar)\n    /// @param message The string message to verify\n    /// @param network Network identifier (true for mainnet, false for testnet)\n    function step_0_VM_assignValues(\n        Point calldata publicKey,\n        Signature calldata signature,\n        string calldata message,\n        bool network\n    ) external returns (uint256) {\n        if (!isValidPublicKey(publicKey)) revert InvalidPublicKey();\n\n        uint256 toSetId = vmCounter;\n        ++vmCounter;\n\n        VerifyMessageState storage toPush = vmLifeCycle[toSetId];\n        toPush.atStep = 0;\n        toPush.publicKey = publicKey;\n        toPush.signature = signature;\n        toPush.message = message;\n        toPush.mainnet = network;\n        toPush.init = true;\n\n        toPush.prefix = network\n            ? \"MinaSignatureMainnet\"\n            : \"CodaSignature*******\";\n\n        vmLifeCycleCreator[toSetId] = msg.sender;\n\n        return toSetId;\n    }\n\n    /// @notice Compute hash of the message with network prefix\n    /// ==================================================\n    /// Matches the first part of verify():\n    /// let e = hashMessage(message, pk, r, networkId)\n    /// Process:\n    /// 1. Convert string message to bytes\n    /// 2. Append public key coordinates and signature.r\n    /// 3. Apply network prefix and hash\n    /// @param vmId Verification state identifier\n    function step_1_VM(uint256 vmId) external isValidVMId(vmId) {\n        VerifyMessageState storage current = vmLifeCycle[vmId];\n        if (current.atStep != 0) revert StepSkipped();\n        if (!current.init) revert(\"Not initialized\");\n\n        // Cache values to reduce storage reads\n        string memory message = current.message;\n        Point memory publicKey = current.publicKey;\n        uint256 sigR = current.signature.r;\n        string memory prefix = current.prefix;\n\n        current.messageHash = hashMessageLegacy(\n            message,\n            publicKey,\n            sigR,\n            prefix\n        );\n        current.atStep = 1;\n    }\n\n    /// @notice Convert public key to curve point\n    /// ==================================================\n    /// From o1js: PublicKey.toGroup(publicKey)\n    /// This converts compressed public key format (x, isOdd)\n    /// to full curve point representation by:\n    /// 1. Computing y² = x³ + 5 (Pallas curve equation)\n    /// 2. Taking square root\n    /// 3. Selecting appropriate y value based on isOdd\n    /// @param vmId Verification state identifier\n    function step_2_VM(uint256 vmId) external isValidVMId(vmId) {\n        VerifyMessageState storage current = vmLifeCycle[vmId];\n        if (current.atStep != 1) revert StepSkipped();\n\n        uint256 pubKeyX = current.publicKey.x;\n        uint256 pubKeyY = current.publicKey.y;\n\n        current.pkInGroup = _defaultToGroup(\n            PointCompressed({x: pubKeyX, isOdd: (pubKeyY & 1 == 1)})\n        );\n\n        current.atStep = 2;\n    }\n\n    /// @notice Compute s*G where G is generator point\n    /// ==================================================\n    /// From o1js: scale(one, s)\n    /// Critical: Do not reduce scalar by SCALAR_MODULUS\n    /// Uses projective coordinates internally for efficiency\n    /// Must use exact generator point coordinates from o1js:\n    /// G.x = 1\n    /// G.y = specific value from PallasConstants\n    /// @param vmId Verification state identifier\n    function step_3_VM(uint256 vmId) external isValidVMId(vmId) {\n        VerifyMessageState storage current = vmLifeCycle[vmId];\n        if (current.atStep != 2) revert StepSkipped();\n\n        Point memory G = Point(G_X, G_Y);\n        current.sG = scalarMul(G, current.signature.s);\n        current.atStep = 3;\n    }\n\n    /// @notice Compute e*publicKey\n    /// ==================================================\n    /// From o1js: scale(Group.toProjective(pk), e)\n    /// where e is the message hash computed in step 1\n    /// Uses same scalar multiplication as s*G\n    /// Takes public key point from step 2\n    /// @param vmId Verification state identifier\n    function step_4_VM(uint256 vmId) external isValidVMId(vmId) {\n        VerifyMessageState storage current = vmLifeCycle[vmId];\n        if (current.atStep != 3) revert StepSkipped();\n\n        Point memory pkInGroup = current.pkInGroup;\n        uint256 messageHash = current.messageHash;\n\n        current.ePk = scalarMul(pkInGroup, messageHash);\n        current.atStep = 4;\n    }\n\n    /// @notice Compute R = sG - ePk\n    /// ==================================================\n    /// From o1js: sub(scale(one, s), scale(Group.toProjective(pk), e))\n    /// Implemented as point addition with negated ePk\n    /// Point negation on Pallas: (x, -y)\n    /// R will be used for final verification\n    /// @param vmId Verification state identifier\n    function step_5_VM(uint256 vmId) external isValidVMId(vmId) {\n        VerifyMessageState storage current = vmLifeCycle[vmId];\n        if (current.atStep != 4) revert StepSkipped();\n\n        uint256 negY;\n        unchecked {\n            negY = FIELD_MODULUS - current.ePk.y;\n        }\n\n        current.R = addPoints(current.sG, Point(current.ePk.x, negY));\n        current.atStep = 5;\n    }\n\n    /// @notice Final signature verification\n    /// ==================================================\n    /// From o1js:\n    /// let { x: rx, y: ry } = Group.fromProjective(R);\n    /// return Field.isEven(ry) && Field.equal(rx, r);\n    /// Two conditions must be met:\n    /// 1. R.x equals signature.r\n    /// 2. R.y is even\n    /// @param vmId Verification state identifier\n    /// @return bool True if signature is valid, false otherwise\n    function step_6_VM(uint256 vmId) external isValidVMId(vmId) returns (bool) {\n        VerifyMessageState storage current = vmLifeCycle[vmId];\n        if (current.atStep != 5) revert StepSkipped();\n\n        Point memory R = current.R;\n        uint256 sigR = current.signature.r;\n\n        current.isValid = (R.x == sigR) && (R.y & 1 == 0);\n        current.atStep = 6;\n\n        bytes memory stateBytesCompressed = packVerifyMessageStateCompressed(\n            current,\n            vmId\n        );\n        vmLifeCycleBytesCompressed[vmId] = stateBytesCompressed;\n\n        return current.isValid;\n    }\n\n    /// @notice Packs a VerifyMessageState into a compressed bytes format for efficient storage\n    /// @dev Combines fixed-length data with the dynamic message string using abi.encodePacked and abi.encode\n    /// @param state The VerifyMessageState to be compressed\n    /// @param vmId The unique identifier for this message verification state\n    /// @return bytes The packed binary representation of the state\n    function packVerifyMessageStateCompressed(\n        VerifyMessageState memory state,\n        uint256 vmId\n    ) public pure returns (bytes memory) {\n        bytes memory fixedData = abi.encodePacked(\n            TYPE_VERIFY_MESSAGE,\n            vmId,\n            state.mainnet,\n            state.isValid,\n            state.publicKey.x,\n            state.publicKey.y,\n            state.signature.r,\n            state.signature.s,\n            state.messageHash\n        );\n\n        return abi.encodePacked(fixedData, abi.encode(state.message));\n    }\n\n    /// @notice Converts a compressed point to its full curve point representation\n    /// @dev Implements point decompression for Pallas curve (y² = x³ + 5)\n    /// Process:\n    /// 1. Calculate y² using curve equation\n    /// 2. Find square root of y²\n    /// 3. Choose correct y value based on oddness flag\n    /// @param compressed The compressed point containing x-coordinate and oddness flag\n    /// @return Point Complete point with both x and y coordinates\n    function _defaultToGroup(\n        PointCompressed memory compressed\n    ) internal view returns (Point memory) {\n        uint256 _x = compressed.x;\n\n        uint256 x2 = mulmod(_x, _x, FIELD_MODULUS);\n        uint256 y2 = addmod(mulmod(x2, _x, FIELD_MODULUS), BEQ, FIELD_MODULUS);\n\n        uint256 _y = sqrtmod(y2, FIELD_MODULUS);\n\n        if ((_y & 1 == 1) != compressed.isOdd) {\n            _y = FIELD_MODULUS - _y;\n        }\n\n        return Point({x: _x, y: _y});\n    }\n}\n"
    },
    "contracts/kimchi/PallasConstants.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract PallasConstants {\n    // Poseidon parameters matching poseidonParamsKimchiFp\n    uint256 internal constant POSEIDON_FULL_ROUNDS = 55;\n    uint256 internal constant POSEIDON_STATE_SIZE = 3;\n    uint256 internal constant POSEIDON_RATE = 2;\n    uint256 internal constant POSEIDON_POWER = 7;\n    bool internal constant POSEIDON_HAS_INITIAL_ROUND_CONSTANT = false;\n\n    uint256[3][3] internal mdsMatrix = [\n        [\n            12035446894107573964500871153637039653510326950134440362813193268448863222019,\n            25461374787957152039031444204194007219326765802730624564074257060397341542093,\n            27667907157110496066452777015908813333407980290333709698851344970789663080149\n        ],\n        [\n            4491931056866994439025447213644536587424785196363427220456343191847333476930,\n            14743631939509747387607291926699970421064627808101543132147270746750887019919,\n            9448400033389617131295304336481030167723486090288313334230651810071857784477\n        ],\n        [\n            10525578725509990281643336361904863911009900817790387635342941550657754064843,\n            27437632000253211280915908546961303399777448677029255413769125486614773776695,\n            27566319851776897085443681456689352477426926500749993803132851225169606086988\n        ]\n    ];\n\n    uint256[3][55] internal roundConstants = [\n        [\n            21155079691556475130150866428468322463125560312786319980770950159250751855431,\n            16883442198399350202652499677723930673110172289234921799701652810789093522349,\n            17030687036425314703519085065002231920937594822150793091243263847382891822670\n        ],\n        [\n            25216718237129482752721276445368692059997901880654047883630276346421457427360,\n            9054264347380455706540423067244764093107767235485930776517975315876127782582,\n            26439087121446593160953570192891907825526260324480347638727375735543609856888\n        ],\n        [\n            15251000790817261169639394496851831733819930596125214313084182526610855787494,\n            10861916012597714684433535077722887124099023163589869801449218212493070551767,\n            18597653523270601187312528478986388028263730767495975370566527202946430104139\n        ],\n        [\n            15831416454198644276563319006805490049460322229057756462580029181847589006611,\n            15171856919255965617705854914448645702014039524159471542852132430360867202292,\n            15488495958879593647482715143904752785889816789652405888927117106448507625751\n        ],\n        [\n            19039802679983063488134304670998725949842655199289961967801223969839823940152,\n            4720101937153217036737330058775388037616286510783561045464678919473230044408,\n            10226318327254973427513859412126640040910264416718766418164893837597674300190\n        ],\n        [\n            20878756131129218406920515859235137275859844638301967889441262030146031838819,\n            7178475685651744631172532830973371642652029385893667810726019303466125436953,\n            1996970955918516145107673266490486752153434673064635795711751450164177339618\n        ],\n        [\n            15205545916434157464929420145756897321482314798910153575340430817222504672630,\n            25660296961552699573824264215804279051322332899472350724416657386062327210698,\n            13842611741937412200312851417353455040950878279339067816479233688850376089318\n        ],\n        [\n            1383799642177300432144836486981606294838630135265094078921115713566691160459,\n            1135532281155277588005319334542025976079676424839948500020664227027300010929,\n            4384117336930380014868572224801371377488688194169758696438185377724744869360\n        ],\n        [\n            21725577575710270071808882335900370909424604447083353471892004026180492193649,\n            676128913284806802699862508051022306366147359505124346651466289788974059668,\n            25186611339598418732666781049829183886812651492845008333418424746493100589207\n        ],\n        [\n            10402240124664763733060094237696964473609580414190944671778761753887884341073,\n            11918307118590866200687906627767559273324023585642003803337447146531313172441,\n            16895677254395661024186292503536662354181715337630376909778003268311296637301\n        ],\n        [\n            23818602699032741669874498456696325705498383130221297580399035778119213224810,\n            4285193711150023248690088154344086684336247475445482883105661485741762600154,\n            19133204443389422404056150665863951250222934590192266371578950735825153238612\n        ],\n        [\n            5515589673266504033533906836494002702866463791762187140099560583198974233395,\n            11830435563729472715615302060564876527985621376031612798386367965451821182352,\n            7510711479224915247011074129666445216001563200717943545636462819681638560128\n        ],\n        [\n            24694843201907722940091503626731830056550128225297370217610328578733387733444,\n            27361655066973784653563425664091383058914302579694897188019422193564924110528,\n            21606788186194534241166833954371013788633495786419718955480491478044413102713\n        ],\n        [\n            19934060063390905409309407607814787335159021816537006003398035237707924006757,\n            8495813630060004961768092461554180468161254914257386012937942498774724649553,\n            27524960680529762202005330464726908693944660961000958842417927307941561848461\n        ],\n        [\n            15178481650950399259757805400615635703086255035073919114667254549690862896985,\n            16164780354695672259791105197274509251141405713012804937107314962551600380870,\n            10529167793600778056702353412758954281652843049850979705476598375597148191979\n        ],\n        [\n            721141070179074082553302896292167103755384741083338957818644728290501449040,\n            22044408985956234023934090378372374883099115753118261312473550998188148912041,\n            27068254103241989852888872162525066148367014691482601147536314217249046186315\n        ],\n        [\n            3880429241956357176819112098792744584376727450211873998699580893624868748961,\n            17387097125522937623262508065966749501583017524609697127088211568136333655623,\n            6256814421247770895467770393029354017922744712896100913895513234184920631289\n        ],\n        [\n            2942627347777337187690939671601251987500285937340386328746818861972711408579,\n            24031654937764287280548628128490074801809101323243546313826173430897408945397,\n            14401457902976567713827506689641442844921449636054278900045849050301331732143\n        ],\n        [\n            20170632877385406450742199836933900257692624353889848352407590794211839130727,\n            24056496193857444725324410428861722338174099794084586764867109123681727290181,\n            11257913009612703357266904349759250619633397075667824800196659858304604714965\n        ],\n        [\n            22228158921984425749199071461510152694025757871561406897041788037116931009246,\n            9152163378317846541430311327336774331416267016980485920222768197583559318682,\n            13906695403538884432896105059360907560653506400343268230130536740148070289175\n        ],\n        [\n            7220714562509721437034241786731185291972496952091254931195414855962344025067,\n            27608867305903811397208862801981345878179337369367554478205559689592889691927,\n            13288465747219756218882697408422850918209170830515545272152965967042670763153\n        ],\n        [\n            8251343892709140154567051772980662609566359215743613773155065627504813327653,\n            22035238365102171608166944627493632660244312563934708756134297161332908879090,\n            13560937766273321037807329177749403409731524715067067740487246745322577571823\n        ],\n        [\n            21652518608959234550262559135285358020552897349934571164032339186996805408040,\n            22479086963324173427634460342145551255011746993910136574926173581069603086891,\n            13676501958531751140966255121288182631772843001727158043704693838707387130095\n        ],\n        [\n            5680310394102577950568930199056707827608275306479994663197187031893244826674,\n            25125360450906166639190392763071557410047335755341060350879819485506243289998,\n            22659254028501616785029594492374243581602744364859762239504348429834224676676\n        ],\n        [\n            23101411405087512171421838856759448177512679869882987631073569441496722536782,\n            24149774013240355952057123660656464942409328637280437515964899830988178868108,\n            5782097512368226173095183217893826020351125522160843964147125728530147423065\n        ],\n        [\n            13540762114500083869920564649399977644344247485313990448129838910231204868111,\n            20421637734328811337527547703833013277831804985438407401987624070721139913982,\n            7742664118615900772129122541139124149525273579639574972380600206383923500701\n        ],\n        [\n            1109643801053963021778418773196543643970146666329661268825691230294798976318,\n            16580663920817053843121063692728699890952505074386761779275436996241901223840,\n            14638514680222429058240285918830106208025229459346033470787111294847121792366\n        ],\n        [\n            17080385857812672649489217965285727739557573467014392822992021264701563205891,\n            26176268111736737558502775993925696791974738793095023824029827577569530708665,\n            4382756253392449071896813428140986330161215829425086284611219278674857536001\n        ],\n        [\n            13934033814940585315406666445960471293638427404971553891617533231178815348902,\n            27054912732979753314774418228399230433963143177662848084045249524271046173121,\n            28916070403698593376490976676534962592542013020010643734621202484860041243391\n        ],\n        [\n            24820015636966360150164458094894587765384135259446295278101998130934963922381,\n            7969535238488580655870884015145760954416088335296905520306227531221721881868,\n            7690547696740080985104189563436871930607055124031711216224219523236060212249\n        ],\n        [\n            9712576468091272384496248353414290908377825697488757134833205246106605867289,\n            12148698031438398980683630141370402088785182722473169207262735228500190477924,\n            14359657643133476969781351728574842164124292705609900285041476162075031948227\n        ],\n        [\n            23563839965372067275137992801035780013422228997724286060975035719045352435470,\n            4184634822776323233231956802962638484057536837393405750680645555481330909086,\n            16249511905185772125762038789038193114431085603985079639889795722501216492487\n        ],\n        [\n            11001863048692031559800673473526311616702863826063550559568315794438941516621,\n            4702354107983530219070178410740869035350641284373933887080161024348425080464,\n            23751680507533064238793742311430343910720206725883441625894258483004979501613\n        ],\n        [\n            28670526516158451470169873496541739545860177757793329093045522432279094518766,\n            3568312993091537758218792253361873752799472566055209125947589819564395417072,\n            1819755756343439646550062754332039103654718693246396323207323333948654200950\n        ],\n        [\n            5372129954699791301953948907349887257752247843844511069896766784624930478273,\n            17512156688034945920605615850550150476471921176481039715733979181538491476080,\n            25777105342317622165159064911913148785971147228777677435200128966844208883059\n        ],\n        [\n            25350392006158741749134238306326265756085455157012701586003300872637887157982,\n            20096724945283767296886159120145376967480397366990493578897615204296873954844,\n            8063283381910110762785892100479219642751540456251198202214433355775540036851\n        ],\n        [\n            4393613870462297385565277757207010824900723217720226130342463666351557475823,\n            9874972555132910032057499689351411450892722671352476280351715757363137891038,\n            23590926474329902351439438151596866311245682682435235170001347511997242904868\n        ],\n        [\n            17723373371137275859467518615551278584842947963894791032296774955869958211070,\n            2350345015303336966039836492267992193191479606566494799781846958620636621159,\n            27755207882790211140683010581856487965587066971982625511152297537534623405016\n        ],\n        [\n            6584607987789185408123601849106260907671314994378225066806060862710814193906,\n            609759108847171587253578490536519506369136135254150754300671591987320319770,\n            28435187585965602110074342250910608316032945187476441868666714022529803033083\n        ],\n        [\n            16016664911651770663938916450245705908287192964254704641717751103464322455303,\n            17551273293154696089066968171579395800922204266630874071186322718903959339163,\n            20414195497994754529479032467015716938594722029047207834858832838081413050198\n        ],\n        [\n            19773307918850685463180290966774465805537520595602496529624568184993487593855,\n            24598603838812162820757838364185126333280131847747737533989799467867231166980,\n            11040972566103463398651864390163813377135738019556270484707889323659789290225\n        ],\n        [\n            5189242080957784038860188184443287562488963023922086723850863987437818393811,\n            1435203288979376557721239239445613396009633263160237764653161500252258220144,\n            13066591163578079667911016543985168493088721636164837520689376346534152547210\n        ],\n        [\n            17345901407013599418148210465150865782628422047458024807490502489711252831342,\n            22139633362249671900128029132387275539363684188353969065288495002671733200348,\n            1061056418502836172283188490483332922126033656372467737207927075184389487061\n        ],\n        [\n            10241738906190857416046229928455551829189196941239601756375665129874835232299,\n            27808033332417845112292408673209999320983657696373938259351951416571545364415,\n            18820154989873674261497645724903918046694142479240549687085662625471577737140\n        ],\n        [\n            7983688435214640842673294735439196010654951226956101271763849527529940619307,\n            17067928657801807648925755556866676899145460770352731818062909643149568271566,\n            24472070825156236829515738091791182856425635433388202153358580534810244942762\n        ],\n        [\n            25752201169361795911258625731016717414310986450004737514595241038036936283227,\n            26041505376284666160132119888949817249574689146924196064963008712979256107535,\n            23977050489096115210391718599021827780049209314283111721864956071820102846008\n        ],\n        [\n            26678257097278788410676026718736087312816016749016738933942134600725962413805,\n            10480026985951498884090911619636977502506079971893083605102044931823547311729,\n            21126631300593007055117122830961273871167754554670317425822083333557535463396\n        ],\n        [\n            1564862894215434177641156287699106659379648851457681469848362532131406827573,\n            13247162472821152334486419054854847522301612781818744556576865965657773174584,\n            8673615954922496961704442777870253767001276027366984739283715623634850885984\n        ],\n        [\n            2794525076937490807476666942602262298677291735723129868457629508555429470085,\n            4656175953888995612264371467596648522808911819700660048695373348629527757049,\n            23221574237857660318443567292601561932489621919104226163978909845174616477329\n        ],\n        [\n            1878392460078272317716114458784636517603142716091316893054365153068227117145,\n            2370412714505757731457251173604396662292063533194555369091306667486647634097,\n            17409784861870189930766639925394191888667317762328427589153989811980152373276\n        ],\n        [\n            25869136641898166514111941708608048269584233242773814014385564101168774293194,\n            11361209360311194794795494027949518465383235799633128250259863567683341091323,\n            14913258820718821235077379851098720071902170702113538811112331615559409988569\n        ],\n        [\n            12957012022018304419868287033513141736995211906682903915897515954290678373899,\n            17128889547450684566010972445328859295804027707361763477802050112063630550300,\n            23329219085372232771288306767242735245018143857623151155581182779769305489903\n        ],\n        [\n            1607741027962933685476527275858938699728586794398382348454736018784568853937,\n            2611953825405141009309433982109911976923326848135736099261873796908057448476,\n            7372230383134982628913227482618052530364724821976589156840317933676130378411\n        ],\n        [\n            20203606758501212620842735123770014952499754751430660463060696990317556818571,\n            4678361398979174017885631008335559529633853759463947250620930343087749944307,\n            27176462634198471376002287271754121925750749676999036165457559387195124025594\n        ],\n        [\n            6361981813552614697928697527332318530502852015189048838072565811230204474643,\n            13815234633287489023151647353581705241145927054858922281829444557905946323248,\n            10888828634279127981352133512429657747610298502219125571406085952954136470354\n        ]\n    ];\n}\n"
    },
    "contracts/kimchi/PallasCurve.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// import \"./PallasConstants.sol\";\nimport \"../PallasTypes.sol\";\nimport \"hardhat/console.sol\";\n\n/**\n * @title PallasCurve\n * @dev Implementation of Pallas curve operations\n */\ncontract PallasCurve is PallasTypes {\n    /// @notice Field modulus for Pallas curve\n    uint256 public constant FIELD_MODULUS =\n        0x40000000000000000000000000000000224698fc094cf91b992d30ed00000001;\n\n    /// @notice Scalar field modulus for Pallas curve\n    uint256 public constant SCALAR_MODULUS =\n        0x40000000000000000000000000224698fc0994a8dd8c46eb2100000001;\n\n    /// @notice Curve equation constant (B) where y² = x³ + B\n    uint256 public constant BEQ = 5;\n\n    /// @notice Default signature prefix for testnet\n    string public constant SIGNATURE_PREFIX = \"CodaSignature*******\";\n\n    /// @notice Signature prefix for mainnet\n    string public constant MAINNET_SIGNATURE_PREFIX = \"MinaSignatureMainnet\";\n\n    /// @notice Default length for string operations\n    uint256 public constant DEFAULT_STRING_LENGTH = 128;\n\n    /// @notice Generator point x-coordinate\n    uint256 public constant G_X = 1;\n\n    /// @notice Generator point y-coordinate\n    uint256 public constant G_Y =\n        0x1b74b5a30a12937c53dfa9f06378ee548f655bd4333d477119cf7a23caed2abb;\n\n    /// @notice Performs modular addition\n    /// @dev Wrapper around Solidity's addmod\n    /// @param x First operand\n    /// @param y Second operand\n    /// @param k Modulus\n    /// @return uint256 Result of (x + y) mod k\n    function add(uint x, uint y, uint k) internal pure returns (uint256) {\n        return addmod(x, y, k);\n    }\n\n    /// @notice Performs modular multiplication\n    /// @dev Wrapper around Solidity's mulmod\n    /// @param x First operand\n    /// @param y Second operand\n    /// @param k Modulus\n    /// @return uint256 Result of (x * y) mod k\n    function mul(uint x, uint y, uint k) internal pure returns (uint256) {\n        return mulmod(x, y, k);\n    }\n\n    /// @notice Computes modular multiplicative inverse\n    /// @dev Implements extended Euclidean algorithm for FIELD_MODULUS\n    /// @param a Value to invert\n    /// @return uint256 Modular multiplicative inverse of a\n    function invmod(uint256 a) internal pure returns (uint256) {\n        if (a == 0) revert(\"Cannot invert 0\");\n\n        uint256 t = 0;\n        uint256 newt = 1;\n        uint256 r = FIELD_MODULUS;\n        uint256 newr = a;\n        uint256 quotient;\n        uint256 temp;\n\n        unchecked {\n            while (newr != 0) {\n                quotient = r / newr;\n\n                temp = t;\n                t = newt;\n                newt = temp - quotient * newt;\n\n                temp = r;\n                r = newr;\n                newr = temp - quotient * newr;\n            }\n\n            if (t > FIELD_MODULUS) {\n                t += FIELD_MODULUS;\n            }\n        }\n        return t;\n    }\n\n    /// @notice Performs modular exponentiation\n    /// @dev Uses precompiled contract at address 0x05\n    /// @param base Base value\n    /// @param exponent Exponent value\n    /// @param modulus Modulus for operation\n    /// @return result Result of base^exponent mod modulus\n    function modExp(\n        uint256 base,\n        uint256 exponent,\n        uint256 modulus\n    ) internal view returns (uint256 result) {\n        assembly {\n            // Free memory pointer\n            let p := mload(0x40)\n\n            // Store length of base, exponent and modulus\n            mstore(p, 0x20)\n            mstore(add(p, 0x20), 0x20)\n            mstore(add(p, 0x40), 0x20)\n\n            // Store base, exponent and modulus\n            mstore(add(p, 0x60), base)\n            mstore(add(p, 0x80), exponent)\n            mstore(add(p, 0xa0), modulus)\n\n            // Call precompiled contract for modular exponentiation\n            if iszero(staticcall(gas(), 0x05, p, 0xc0, p, 0x20)) {\n                revert(0, 0)\n            }\n\n            result := mload(p)\n        }\n    }\n\n    /// @notice Computes modular square root\n    /// @dev Implements Tonelli-Shanks algorithm for prime modulus\n    /// @param n Value to find square root of\n    /// @param p Modulus (must be prime)\n    /// @return uint256 Modular square root of n\n    function sqrtmod(uint256 n, uint256 p) internal view returns (uint256) {\n        if (n == 0) return 0;\n\n        // Calculate Q and M where p - 1 = Q * 2^M and Q is odd\n        uint256 Q = p - 1;\n        uint256 M = 0;\n        while (Q % 2 == 0) {\n            Q /= 2;\n            M++;\n        }\n\n        // Find a non-residue z\n        uint256 z = 2;\n        while (true) {\n            if (modExp(z, (p - 1) / 2, p) == p - 1) break; // Found a non-residue\n            z++;\n        }\n\n        uint256 c = modExp(z, Q, p);\n        uint256 t = modExp(n, Q >> 1, p); // n^((Q-1)/2)\n        uint256 R = mulmod(t, n, p); // n^((Q+1)/2)\n        t = mulmod(t, R, p); // n^Q\n\n        while (t != 1) {\n            uint256 i = 0;\n            uint256 s = t;\n            while (s != 1 && i < M) {\n                s = mulmod(s, s, p);\n                i++;\n            }\n            require(i < M, \"Square root does not exist\");\n\n            uint256 b = c;\n            for (uint256 j = 0; j < M - i - 1; j++) {\n                b = mulmod(b, b, p);\n            }\n            M = i;\n            c = mulmod(b, b, p);\n            t = mulmod(t, c, p);\n            R = mulmod(R, b, p);\n        }\n\n        return R;\n    }\n\n    /// @notice Checks if a number is even\n    /// @dev Uses bitwise AND operation\n    /// @param x Number to check\n    /// @return bool True if number is even\n    function isEven(uint256 x) internal pure returns (bool) {\n        return (x & 1) == 0;\n    }\n\n    /// @notice Converts a point from affine to projective coordinates\n    /// @dev Used for efficient point operations. Returns (1:1:0) for point at infinity\n    /// @param p Point in affine coordinates (x,y)\n    /// @return ProjectivePoint Point in projective coordinates (X:Y:Z)\n    function toProjective(\n        Point memory p\n    ) internal pure returns (ProjectivePoint memory) {\n        if (p.x == 0 && p.y == 0) {\n            return ProjectivePoint(1, 1, 0); // Point at infinity\n        }\n        return ProjectivePoint(p.x, p.y, 1);\n    }\n\n    /// @notice Converts a point from projective to affine coordinates\n    /// @dev Performs modular inverse computation for Z coordinate\n    /// @param p Point in projective coordinates (X:Y:Z)\n    /// @return Point Point in affine coordinates (x,y)\n    function toAffine(\n        ProjectivePoint memory p\n    ) internal pure returns (Point memory) {\n        if (p.z == 0) {\n            return Point(0, 0); // Point at infinity\n        }\n\n        uint256 zinv = invmod(p.z);\n        uint256 zinv_squared = mulmod(zinv, zinv, FIELD_MODULUS);\n\n        return\n            Point(\n                mulmod(p.x, zinv_squared, FIELD_MODULUS),\n                mulmod(\n                    p.y,\n                    mulmod(zinv, zinv_squared, FIELD_MODULUS),\n                    FIELD_MODULUS\n                )\n            );\n    }\n\n    /// @notice Verifies if a point lies on the Pallas curve\n    /// @dev Checks if point satisfies y² = x³ + 5 (Pallas curve equation)\n    /// @param p Point to check\n    /// @return bool True if point is on curve\n    function isOnCurve(Point memory p) internal pure returns (bool) {\n        if (p.x >= FIELD_MODULUS || p.y >= FIELD_MODULUS) {\n            return false;\n        }\n\n        uint256 lhs = mulmod(p.y, p.y, FIELD_MODULUS);\n        uint256 x2 = mulmod(p.x, p.x, FIELD_MODULUS);\n        uint256 x3 = mulmod(x2, p.x, FIELD_MODULUS);\n        uint256 rhs = addmod(x3, BEQ, FIELD_MODULUS);\n\n        return lhs == rhs;\n    }\n\n    /// @notice Doubles a point in projective coordinates\n    /// @dev Specialized doubling formula for Pallas curve, matching o1js implementation\n    /// @param g Point to double in projective coordinates\n    /// @return ProjectivePoint Doubled point\n    function projectiveDouble(\n        ProjectivePoint memory g\n    ) internal pure returns (ProjectivePoint memory) {\n        if (g.z == 0) return g;\n        if (g.y == 0) revert(\"Cannot double point with y=0\");\n\n        unchecked {\n            // Cache x, y, z values\n            uint256 x = g.x;\n            uint256 y = g.y;\n            uint256 z = g.z;\n\n            // A = X1^2\n            uint256 A = mulmod(x, x, FIELD_MODULUS);\n            // B = Y1^2\n            uint256 B = mulmod(y, y, FIELD_MODULUS);\n            // C = B^2\n            uint256 C = mulmod(B, B, FIELD_MODULUS);\n\n            // Cache X1+B\n            uint256 xPlusB = addmod(x, B, FIELD_MODULUS);\n            // D = 2*((X1+B)^2-A-C)\n            uint256 D = mulmod(\n                2,\n                addmod(\n                    mulmod(xPlusB, xPlusB, FIELD_MODULUS),\n                    FIELD_MODULUS - addmod(A, C, FIELD_MODULUS),\n                    FIELD_MODULUS\n                ),\n                FIELD_MODULUS\n            );\n\n            // E = 3*A\n            uint256 E = mulmod(3, A, FIELD_MODULUS);\n            // F = E^2\n            uint256 F = mulmod(E, E, FIELD_MODULUS);\n\n            // Calculate final coordinates\n            uint256 X3 = addmod(\n                F,\n                FIELD_MODULUS - mulmod(2, D, FIELD_MODULUS),\n                FIELD_MODULUS\n            );\n            uint256 Y3 = addmod(\n                mulmod(\n                    E,\n                    addmod(D, FIELD_MODULUS - X3, FIELD_MODULUS),\n                    FIELD_MODULUS\n                ),\n                FIELD_MODULUS - mulmod(8, C, FIELD_MODULUS),\n                FIELD_MODULUS\n            );\n            uint256 Z3 = mulmod(2, mulmod(y, z, FIELD_MODULUS), FIELD_MODULUS);\n\n            return ProjectivePoint(X3, Y3, Z3);\n        }\n    }\n\n    /// @notice Adds two points in projective coordinates\n    /// @dev Implements complete addition formulas for Pallas curve, matching o1js behavior\n    /// @param g First point in projective coordinates\n    /// @param h Second point in projective coordinates\n    /// @return ProjectivePoint Sum of the points\n    function projectiveAdd(\n        ProjectivePoint memory g,\n        ProjectivePoint memory h\n    ) internal pure returns (ProjectivePoint memory) {\n        if (g.z == 0) return h;\n        if (h.z == 0) return g;\n\n        unchecked {\n            // Cache values\n            uint256 z1 = g.z;\n            uint256 z2 = h.z;\n\n            uint256 Z1Z1 = mulmod(z1, z1, FIELD_MODULUS);\n            uint256 Z2Z2 = mulmod(z2, z2, FIELD_MODULUS);\n            uint256 U1 = mulmod(g.x, Z2Z2, FIELD_MODULUS);\n            uint256 U2 = mulmod(h.x, Z1Z1, FIELD_MODULUS);\n            uint256 S1 = mulmod(\n                g.y,\n                mulmod(z2, Z2Z2, FIELD_MODULUS),\n                FIELD_MODULUS\n            );\n            uint256 S2 = mulmod(\n                h.y,\n                mulmod(z1, Z1Z1, FIELD_MODULUS),\n                FIELD_MODULUS\n            );\n            uint256 H = addmod(U2, FIELD_MODULUS - U1, FIELD_MODULUS);\n\n            if (H == 0) {\n                if (S1 == S2) {\n                    return projectiveDouble(g);\n                }\n                if (addmod(S1, S2, FIELD_MODULUS) == 0) {\n                    return ProjectivePoint(1, 1, 0);\n                }\n                revert(\"Invalid point addition\");\n            }\n\n            // Rest of calculations in one unchecked block for gas savings\n            uint256 I = mulmod(mulmod(H, H, FIELD_MODULUS), 4, FIELD_MODULUS);\n            uint256 J = mulmod(H, I, FIELD_MODULUS);\n            uint256 r = mulmod(\n                2,\n                addmod(S2, FIELD_MODULUS - S1, FIELD_MODULUS),\n                FIELD_MODULUS\n            );\n            uint256 V = mulmod(U1, I, FIELD_MODULUS);\n\n            uint256 X3 = addmod(\n                mulmod(r, r, FIELD_MODULUS),\n                FIELD_MODULUS -\n                    addmod(J, mulmod(2, V, FIELD_MODULUS), FIELD_MODULUS),\n                FIELD_MODULUS\n            );\n\n            uint256 Y3 = addmod(\n                mulmod(\n                    r,\n                    addmod(V, FIELD_MODULUS - X3, FIELD_MODULUS),\n                    FIELD_MODULUS\n                ),\n                FIELD_MODULUS -\n                    mulmod(2, mulmod(S1, J, FIELD_MODULUS), FIELD_MODULUS),\n                FIELD_MODULUS\n            );\n\n            uint256 Z3 = mulmod(\n                addmod(\n                    mulmod(\n                        addmod(z1, z2, FIELD_MODULUS),\n                        addmod(z1, z2, FIELD_MODULUS),\n                        FIELD_MODULUS\n                    ),\n                    FIELD_MODULUS - addmod(Z1Z1, Z2Z2, FIELD_MODULUS),\n                    FIELD_MODULUS\n                ),\n                H,\n                FIELD_MODULUS\n            );\n\n            return ProjectivePoint(X3, Y3, Z3);\n        }\n    }\n\n    /// @notice Adds two points in affine coordinates\n    /// @dev Converts to projective, adds, then converts back to affine\n    /// @param p1 First point in affine coordinates\n    /// @param p2 Second point in affine coordinates\n    /// @return Point Sum of the points in affine coordinates\n    function addPoints(\n        Point memory p1,\n        Point memory p2\n    ) internal pure returns (Point memory) {\n        ProjectivePoint memory g = toProjective(p1);\n        ProjectivePoint memory h = toProjective(p2);\n        ProjectivePoint memory r = projectiveAdd(g, h);\n        return toAffine(r);\n    }\n\n    /// @notice Performs scalar multiplication of a point\n    /// @dev Implements double-and-add algorithm, matching o1js behavior\n    /// @param p Base point to multiply\n    /// @param scalar Scalar value to multiply by\n    /// @return Point Result of scalar multiplication\n    function scalarMul(\n        Point memory p,\n        uint256 scalar\n    ) internal pure returns (Point memory) {\n        ProjectivePoint memory g = toProjective(p);\n        ProjectivePoint memory result = ProjectivePoint(1, 1, 0);\n        ProjectivePoint memory current = g;\n\n        // scalar = scalar % SCALAR_MODULUS;\n        while (scalar > 0) {\n            if (scalar & 1 == 1) {\n                result = projectiveAdd(result, current);\n            }\n            current = projectiveDouble(current);\n            scalar >>= 1;\n        }\n\n        return toAffine(result);\n    }\n}\n"
    },
    "contracts/kimchi/Poseidon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./PallasConstants.sol\";\nimport \"./PallasCurve.sol\";\nimport \"hardhat/console.sol\";\n\n/**\n * @title PoseidonT3\n * @dev Implementation of Poseidon hash function for t = 3 (2 inputs)\n */\ncontract Poseidon is PallasCurve, PallasConstants {\n    uint256 internal constant CODA_PREFIX_FIELD =\n        240717916736854602989207148466022993262069182275;\n    uint256 internal constant MINA_PREFIX_FIELD =\n        664504924603203994814403132056773144791042910541;\n\n    /// @notice Computes x^7 mod FIELD_MODULUS\n    /// @dev Optimized power7 implementation matching o1js\n    /// @param x Base value\n    /// @return uint256 Result of x^7 mod FIELD_MODULUS\n    function power7(uint256 x) internal pure returns (uint256) {\n        uint256 x2 = mulmod(x, x, FIELD_MODULUS);\n        uint256 x3 = mulmod(x2, x, FIELD_MODULUS);\n        uint256 x6 = mulmod(x3, x3, FIELD_MODULUS);\n        return mulmod(x6, x, FIELD_MODULUS);\n    }\n\n    // Matrix and Round Constants\n    /// @notice Retrieves value from MDS matrix at specified position\n    /// @dev Used in the Poseidon permutation\n    /// @param row Row index of MDS matrix\n    /// @param col Column index of MDS matrix\n    /// @return uint256 Value at specified position\n    function getMdsValue(\n        uint256 row,\n        uint256 col\n    ) internal view returns (uint256) {\n        require(row < 3 && col < 3, \"Invalid MDS indices\");\n        return mdsMatrix[row][col];\n    }\n\n    /// @notice Retrieves round constant for specified round and position\n    /// @dev Used in the Poseidon permutation\n    /// @param round Round number\n    /// @param pos Position within the round\n    /// @return uint256 Round constant value\n    function getRoundConstant(\n        uint256 round,\n        uint256 pos\n    ) internal view returns (uint256) {\n        require(\n            round < POSEIDON_FULL_ROUNDS && pos < 3,\n            \"Invalid round constant indices\"\n        );\n        return roundConstants[round][pos];\n    }\n\n    /// @notice Performs matrix multiplication with MDS matrix\n    /// @dev Exactly matches o1js implementation\n    /// @param state Current state array\n    /// @return result Result of matrix multiplication\n    function mdsMultiply(\n        uint256[3] memory state\n    ) internal view returns (uint256[3] memory result) {\n        result[0] = addmod(\n            addmod(\n                mulmod(getMdsValue(0, 0), state[0], FIELD_MODULUS),\n                mulmod(getMdsValue(0, 1), state[1], FIELD_MODULUS),\n                FIELD_MODULUS\n            ),\n            mulmod(getMdsValue(0, 2), state[2], FIELD_MODULUS),\n            FIELD_MODULUS\n        );\n\n        result[1] = addmod(\n            addmod(\n                mulmod(getMdsValue(1, 0), state[0], FIELD_MODULUS),\n                mulmod(getMdsValue(1, 1), state[1], FIELD_MODULUS),\n                FIELD_MODULUS\n            ),\n            mulmod(getMdsValue(1, 2), state[2], FIELD_MODULUS),\n            FIELD_MODULUS\n        );\n\n        result[2] = addmod(\n            addmod(\n                mulmod(getMdsValue(2, 0), state[0], FIELD_MODULUS),\n                mulmod(getMdsValue(2, 1), state[1], FIELD_MODULUS),\n                FIELD_MODULUS\n            ),\n            mulmod(getMdsValue(2, 2), state[2], FIELD_MODULUS),\n            FIELD_MODULUS\n        );\n    }\n\n    // State Management\n    /// @notice Creates initial state array [0, 0, 0]\n    /// @dev Used to initialize Poseidon hash state\n    /// @return uint256[3] Initial state array\n    function initialState() internal pure returns (uint256[3] memory) {\n        return [uint256(0), uint256(0), uint256(0)];\n    }\n\n    /// @notice Performs the Poseidon permutation on a state\n    /// @dev Core permutation function for Poseidon hash\n    /// @param state Input state array\n    /// @return uint256[3] Permuted state\n    function poseidonPermutation(\n        uint256[3] memory state\n    ) internal view returns (uint256[3] memory) {\n        for (uint256 round = 0; round < POSEIDON_FULL_ROUNDS; round++) {\n            state[0] = power7(state[0]);\n            state[1] = power7(state[1]);\n            state[2] = power7(state[2]);\n\n            state = mdsMultiply(state);\n\n            state[0] = addmod(\n                state[0],\n                getRoundConstant(round, 0),\n                FIELD_MODULUS\n            );\n            state[1] = addmod(\n                state[1],\n                getRoundConstant(round, 1),\n                FIELD_MODULUS\n            );\n            state[2] = addmod(\n                state[2],\n                getRoundConstant(round, 2),\n                FIELD_MODULUS\n            );\n        }\n        return state;\n    }\n\n    /// @notice Updates state with input values\n    /// @dev Processes input in blocks of POSEIDON_RATE size\n    /// @param state Current state array\n    /// @param input Input values to process\n    /// @return uint256[3] Updated state\n    function update(\n        uint256[3] memory state,\n        uint256[] memory input\n    ) internal view returns (uint256[3] memory) {\n        if (input.length == 0) {\n            return poseidonPermutation(state);\n        }\n\n        uint256 blockIndex;\n        while (blockIndex < input.length) {\n            // Unrolled POSEIDON_RATE loop for common case of rate=2\n            if (blockIndex < input.length) {\n                state[0] = addmod(state[0], input[blockIndex], FIELD_MODULUS);\n            }\n            if (blockIndex + 1 < input.length) {\n                state[1] = addmod(\n                    state[1],\n                    input[blockIndex + 1],\n                    FIELD_MODULUS\n                );\n            }\n\n            state = poseidonPermutation(state);\n            blockIndex += POSEIDON_RATE;\n        }\n\n        return state;\n    }\n\n    /// String/Field Conversions\n    /// @notice Converts a string prefix to a field element\n    /// @dev Processes bytes in little-endian order, matching o1js implementation\n    /// @param prefix The string to convert\n    /// @return uint256 Field element representation of the prefix\n    function prefixToField(\n        string memory prefix\n    ) internal pure returns (uint256) {\n        bytes memory prefixBytes = bytes(prefix);\n        require(prefixBytes.length < 32, \"prefix too long\");\n\n        uint256 result = 0;\n        // Process in little-endian order (like o1js)\n        for (uint i = 0; i < 32; i++) {\n            if (i < prefixBytes.length) {\n                result |= uint256(uint8(prefixBytes[i])) << (i * 8);\n            }\n        }\n\n        return result % FIELD_MODULUS;\n    }\n\n    /// @notice Converts a string to a field element\n    /// @dev Processes bytes in little-endian order, similar to prefixToField\n    /// @param str The string to convert\n    /// @return uint256 Field element representation of the string\n    function stringToField(string memory str) internal pure returns (uint256) {\n        bytes memory strBytes = bytes(str);\n        require(strBytes.length < 32, \"prefix too long\");\n\n        uint256 result = 0;\n        // Process in little-endian order (like o1js)\n        for (uint i = 0; i < 32; i++) {\n            if (i < strBytes.length) {\n                result |= uint256(uint8(strBytes[i])) << (i * 8);\n            }\n            // zeros are handled implicitly\n        }\n\n        return result % FIELD_MODULUS;\n    }\n\n    // Main Hashing Functions\n    /// @notice Computes Poseidon hash of input array\n    /// @dev Main hashing function without prefix\n    /// @param input Array of field elements to hash\n    /// @return uint256 Resulting hash\n    function poseidonHash(\n        uint256[] memory input\n    ) public view returns (uint256) {\n        uint256[3] memory state = initialState();\n        state = update(state, input);\n\n        return state[0];\n    }\n\n    /// @notice Computes Poseidon hash with prefix\n    /// @dev Hashes prefix followed by input array\n    /// @param prefix String prefix to prepend\n    /// @param input Array of field elements to hash\n    /// @return uint256 Resulting hash\n    function poseidonHashWithPrefix(\n        string memory prefix,\n        uint256[] memory input\n    ) public view returns (uint256) {\n        uint256[3] memory state = initialState();\n\n        uint256[] memory prefixArray = new uint256[](1);\n        prefixArray[0] = prefixToField(prefix);\n        state = update(state, prefixArray);\n        state = update(state, input);\n\n        return state[0];\n    }\n\n    /// @notice Hashes message fields with public key and signature data\n    /// @dev Implements message hashing as specified in the signing scheme\n    /// @param fields Array of message fields\n    /// @param publicKey Public key point\n    /// @param r X-coordinate of signature point\n    /// @param prefix Network-specific prefix\n    /// @return uint256 Resulting message hash\n    function hashMessage(\n        uint256[] memory fields,\n        Point memory publicKey,\n        uint256 r,\n        string memory prefix\n    ) public view returns (uint256) {\n        // Pre-allocate array and copy fields\n        uint256[] memory fullInput = new uint256[](fields.length + 3);\n\n        assembly {\n            let length := mload(fields)\n            let srcPtr := add(fields, 0x20)\n            let destPtr := add(fullInput, 0x20)\n            // Copy fields array\n            for {\n                let i := 0\n            } lt(i, length) {\n                i := add(i, 1)\n            } {\n                mstore(\n                    add(destPtr, mul(i, 0x20)),\n                    mload(add(srcPtr, mul(i, 0x20)))\n                )\n            }\n            // Append public key and signature\n            mstore(add(destPtr, mul(length, 0x20)), mload(publicKey))\n            mstore(\n                add(destPtr, mul(add(length, 1), 0x20)),\n                mload(add(publicKey, 0x20))\n            )\n            mstore(add(destPtr, mul(add(length, 2), 0x20)), r)\n        }\n\n        // Use cached prefix value\n        uint256[3] memory state = initialState();\n        uint256[] memory prefixArray = new uint256[](1);\n        prefixArray[0] = keccak256(bytes(prefix)) ==\n            keccak256(bytes(\"MinaSignatureMainnet\"))\n            ? MINA_PREFIX_FIELD\n            : CODA_PREFIX_FIELD;\n\n        state = update(state, prefixArray);\n        state = update(state, fullInput);\n\n        return state[0];\n    }\n}\n"
    },
    "contracts/legacy/PallasConstantsLegacy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract PallasConstantsLegacy {\n    // Poseidon parameters matching poseidonParamsLegacyFp\n    uint256 internal constant POSEIDON_FULL_ROUNDS = 63;\n    uint256 internal constant POSEIDON_STATE_SIZE = 3;\n    uint256 internal constant POSEIDON_RATE = 2;\n    uint256 internal constant POSEIDON_POWER = 5;\n    bool internal constant POSEIDON_HAS_INITIAL_ROUND_CONSTANT = true;\n\n    uint256[3][3] internal mdsMatrix = [\n        [\n            5328350144166205084223774245058198666309664348635459768305312917086056785354,\n            15214731724107930304595906373487084110291887262136882623959435918484004667388,\n            22399519358931858664262538157042328690232277435337286643350379269028878354609\n        ],\n        [\n            10086628405675314879458652402278736459294354590428582803795166650930540770072,\n            17127968360683744052278857147989507037142007029142438136689352416106177192235,\n            14207324749280135281015658576564097509614634975132487654324863824516044294735\n        ],\n        [\n            3059104278162906687184746935153057867173086006783171716838577369156969739687,\n            16755849208683706534025643823697988418063305979108082130624352443958404325985,\n            16889774624482628108075965871448623911656600744832339664842346756371603433407\n        ]\n    ];\n\n    uint256[3][100] internal roundConstants = [\n        [\n            1346081094044643970582493287085428191977688221215786919106342366360741041016,\n            10635969173348128974923358283368657934408577270968219574411363948927109531877,\n            18431955373344919956072236142080066866861234899777299873162413437379924987003\n        ],\n        [\n            5797044060651575840084283729791357462720161727701814038830889113712361837236,\n            931288489507796144596974766082847744938192694315568692730730202141894005205,\n            13659894470945121760517769979107966886673294523737498361566285362771110125394\n        ],\n        [\n            6076231707445968054305995680347976771585015308155855387339303513025362636128,\n            28822740034050339685362260108484262889265034407340240070058997651710236456303,\n            23420266473857869790486107029614186913447272961845992963194006142267563993493\n        ],\n        [\n            13753917374184785903125509246122783296344288469304898921025291716613575849357,\n            22396739346703340038555577564698139382745239004673153148674304627904081092826,\n            13064238335532551154986111986409392866270911640785653458047811526842088084911\n        ],\n        [\n            23165923875642452719095776619341762858050322341374771345641255745672274104746,\n            1876216571769482372914291210815859835162659440705283782713345335434924136736,\n            25448252060136178247213604035267580231762596830634036926922217427938159849142\n        ],\n        [\n            2161875315509206970842862195937323600322108268401381254431163181777726747153,\n            19159855698625842998331760283165907305622417625829203038229273729196960321630,\n            24828563875172432296791053766778475681869974948122169083176331088266823626561\n        ],\n        [\n            15959479662608710141128458274961057999257961784282074767105536637788386907463,\n            8006369581283017287449277389162056290714176164680299906116833200510117952858,\n            18794336794618132129607701188430371953320538976527988886453665523008714542779\n        ],\n        [\n            19408271715954593722501381885401160867835377473312521553027032015227895029571,\n            13654747284005184272412579731446984220568337794941823533879059135026064413631,\n            14094055032353750931629930778481002727722804310855727808905931659115939920989\n        ],\n        [\n            13241818625838429282823260827177433104574315653706102174619924764342778921524,\n            25709259239494174564705048436260891089407557689981668111890003079561388887725,\n            26866626910239634723971078462134580196819809568632305020800296809092442642381\n        ],\n        [\n            23886826350713085163238005260075062110062681905356997481925492650252417143049,\n            16853602711255261520713463306790360324679500458440235992292027384928526778856,\n            18444710386168488194610417945072711530390091945738595259171890487504771614189\n        ],\n        [\n            16896789009769903615328691751424474161656500693270070895928499575572871141439,\n            23842266984616972287898037872537536999393060934879414668030219493005225085992,\n            24369698563802298585444760814856330583118549706483939267059237951238240608187\n        ],\n        [\n            25360195173713628054110426524260405937218170863260484655473435413697869858790,\n            1486437708678506228822038923353468635394979165769861487132708983207562337116,\n            18653498960429911228442559598959970807723487073275324556015861725806677047150\n        ],\n        [\n            18878179044241268037057256060083772636369783391816038647949347814518015576522,\n            178715779905629247116805974152863592571182389085419970371289655361443016848,\n            8381006794425876451998903949255801618132578446062133243427381291481465852184\n        ],\n        [\n            4176946262813877719206528849579392120806054050640974718891398605746592169324,\n            16376345520728802444699629729684297833862527190772376028981704525651968727081,\n            8399065769082251057361366626601550736334213197703006866551331927128775757919\n        ],\n        [\n            15435308585611812393531506745122614542196708285088622615406141986333182280857,\n            4082259282787276939431186930090898350392871145699460879678141552997816391817,\n            26348742719959309014730178326877937464605873211235784184917342950648457078699\n        ],\n        [\n            9707631711734344681918469569872517425107158187591261754498805460753455298868,\n            27910768846011709391567916011595957279088224137468948238696800459136335473132,\n            20407239095656434708569263842372155762970847207558227886302782130015730063802\n        ],\n        [\n            22726225412881182965250630589245572283256255052470345984553083359461473893802,\n            12443967854426795490638709950679156338200426963050610832781263082981525248175,\n            27102543658848146076219989119639465430524061997280788166887046421706499775415\n        ],\n        [\n            14427224233985680214097547669945064793149553513421479297921556194475574770861,\n            22917454832925781549840198815703114840452733537799472739275668965081704937832,\n            3455076056123630366063931123762198941796412458154689469887583689725886013901\n        ],\n        [\n            4513100023937785913596662867311227004762025658663076805918211014066645403017,\n            18187619530784075723418065322038024507729605774832001333883311123910954334059,\n            9447065431426150382325592560406989926365684509675374414068135115024495130938\n        ],\n        [\n            3227816098015819796753427754968234889554095489076864339942014527747604603014,\n            14798316759185072116520458171957899889489461918408669809912344751222514418582,\n            23013904852315603905843158448056763116188801262838729536210355401378476650033\n        ],\n        [\n            20979191509934291452182967564058656088941447895799901211038858159903580333267,\n            20772973010251235271448378823573767262405703078344288856168565499702414379868,\n            10105446427739226002497411811738001382334316505480517822035303561899927603685\n        ],\n        [\n            11079074761356717003579108002319997196881121172538617046865136940931215263187,\n            4693927775411489288330326150094711670434597808961717172753867514688725690438,\n            18581720304902876944842830383273503265470859268712618325357902881821721540119\n        ],\n        [\n            3065369948183164725765083504606321683481629263177690053939474679689088169185,\n            18515622379147081456114962668688706121098539582467584736624699157043365677487,\n            17563088600719312877716085528177751048248154461245613291986010180187238198006\n        ],\n        [\n            26199746176994924146211004840756471702409132230831594954444947705902602287290,\n            7576136600627345523051497639367002272003104458453478964661395239732811642605,\n            20058687874612168338994287374025378897088936171250328231848098497610185784281\n        ],\n        [\n            16894722532414195606958290526999761110785277556463400588047573469106594850228,\n            13961730805696859614283621225672002906734926278118993580398533742874863598733,\n            25256842011135514243352951950573936602906198374305137963222382546140030647211\n        ],\n        [\n            18530360047537856737482157200091774590035773602620205695980247565433703032532,\n            23014819965938599260086897799541446473887833964178378497976832161473586995397,\n            27911426213258307990762460361663504655967992659180759140364181941291843542489\n        ],\n        [\n            1067338118323302017358103178057182291035336430305886255160210378977812067042,\n            17219092885519007424608854460610388434712113621163885775309496940189894433620,\n            16432921127615937542183846559291144733339643093361323334499888895135356545408\n        ],\n        [\n            28608851042959977114787048070153637607786033079364369200270218128830983558707,\n            10121629780013165888398831090128011045011860641816380162950736555305748332191,\n            2348036340843128746981122630521268144839343500596932561106759754644596320722\n        ],\n        [\n            16619881370356823200358060093334065394764987467483650323706184068451904156452,\n            2302436627861989749837563733434625231689351276818486757748445924305258835336,\n            27514536540953539473280001431110316405453388911725550380123851609652679788049\n        ],\n        [\n            9459277727420672604737117687200019308525004979918488827092207438664125039815,\n            23425670740358068509956137586663046763224562225383386726193078231034380596217,\n            7641885067011661443791509688937280323563328029517832788240965464798835873658\n        ],\n        [\n            9579420382351699601929202663836555665702024548386778299996961509578687980280,\n            18513671386572584282611234979588379470994484682444053600751415262497237017703,\n            24923151431234706142737221165378041700050312199585085101919834422744926421604\n        ],\n        [\n            21131320841803068139502705966375283830095161079635803028011171241658723560073,\n            19208476595309656066589572658712717685014329237892885950958199953675225096566,\n            24023185216737416080949689106968568821656545490748664446389634158498624398204\n        ],\n        [\n            7510552996848634969347937904645640209946785877619890235458182993413526028718,\n            3694415017252995094553868781762548289196990492336482360084813900937464847638,\n            9219021070107873028263141554048987416559034633883158827414043929220388719352\n        ],\n        [\n            5058327241234443421111591959922712922949620710493120384930391763032694640881,\n            13148252221647574076185511663661016015859769210867362839817254885265598775418,\n            15186790492457240277904880519227706403545816456632095870015828239411033220638\n        ],\n        [\n            2775942914650502409705888572245750999561427024488403026572311267798009048466,\n            6277965230841030155341171319927732572492215818164736949144854827643964384893,\n            24144742149845235561087977558785057713814731737434473021812189457617252043745\n        ],\n        [\n            25789129719327437503403457598813971826156253950521984610569937361506914183550,\n            21500534320778995945845999974779950304491968082325255355181901574840373597824,\n            17185359848218837018503091932245529880546896465437232425673134558221638601375\n        ],\n        [\n            12253896579078110143384981818031883112606762215016553811786428215758384195713,\n            12956658260778456372481429232709881794962204180363200699121804724437678625542,\n            3023603786717368708677300377055384474816569333060487675635618249403832078921\n        ],\n        [\n            4186492855716808019562789862833898284927736051002588766326482010810259565130,\n            4263939782228419774639068267872291539552889472311225829898746091327730032923,\n            24068843626280451423530509388397151179174104901782990365720205643492047328816\n        ],\n        [\n            14564937827374621319716285527475223392664010281568256859627186463065876537730,\n            28367596550218705971881480694115935470211319172596432472834880507822452927283,\n            28712267437482356021504544448225827500268648754270274754623969882031853409874\n        ],\n        [\n            4542596163006916397403529184431773692747461300288194722982487051249951403191,\n            2530461821259252672899452671728393208543894014761816288817584587718369998371,\n            12886393063011539390567049190923398676964700147222878509238966758839020897414\n        ],\n        [\n            21593897590707514492037699253654745501762191795293908682495110982956631870528,\n            13233005790593128135480716846773978578237145313006994631606474472023504621256,\n            21621863098292803642478350494794106282518362577273973885587684567452726939909\n        ],\n        [\n            26068620073001644720969640099644251616742620988609091568084348314770436291745,\n            18248589586787935500122854210401321966459127818593446990365211078521058875685,\n            21247134484403265289037859533347798468858819117600251067578809852124865474448\n        ],\n        [\n            7947383127165915366383984718363902897504221803836013123394785749404572432524,\n            22173041014621867335598230447618036223462011647696367239478182269973488867154,\n            16773227734018849308448505860847939069870370055633571816925675705713088305139\n        ],\n        [\n            10708707957340055662073314227607620808612686977606082605219160019699644826999,\n            21249897193797038261479589555720746994050836195265348846222835266344091683000,\n            12581195059139097540117398803363514148192715293133623516709277290477633379593\n        ],\n        [\n            19779599816866992123290302397082614570282926215253589712189610064229996603178,\n            21749216503901548676985371189807470207364320167486559936962401093285243029177,\n            17600045923623503357380202389718735904174992978547372448837488832457719009224\n        ],\n        [\n            2732872979548118117758016335601225525660858727422778256671975055129965858636,\n            13703031005128062046175331918702218558750713240446179585947851411173844703597,\n            28447710105386636841938034820015573492556750872924193415447818187228356409281\n        ],\n        [\n            28539960355005748517007309210788803416171161412204526246799800716567376494244,\n            21329318452221893900731030722137844458345358926323127858742388587761302609863,\n            28135302149599894709369178097439582767613940517471323224020113411362601191873\n        ],\n        [\n            24980774120400248734054527936006392540889095705961960837980443629260392758683,\n            20339911045808632098936066397942175169549806052128535543540543556255197716643,\n            7929293103930252545581851978492699598413941396422930641071359388697302362494\n        ],\n        [\n            8911092207145893152276662096451247820054843777071569723455408545101628926203,\n            19648860643145256523615441075182036100116634560394529500146405733687718224516,\n            14635387208623683806428528837466762532853903031263830054986064902455379735903\n        ],\n        [\n            11555212214346132926966321609673228184079851030522218543981385635403167028692,\n            20896918157639814425520058178561910811657326967880217845710779511927814874973,\n            4650158165912007049140499755153804318686705949436165235742106170124284287326\n        ],\n        [\n            13880660273492757167295696447853232191657893303250187467329180558670697369810,\n            8043529172463774320604378774840863923445982272478964686447801046272917236836,\n            2134399296482715903442913099374581981696436050603410080564843555725771329441\n        ],\n        [\n            27320952903412641133501507962185246982787769547770982814240701526492601978122,\n            23417491374379751329394424924400186404791519133465537872457405970098902747611,\n            17612427354278346772575179176139417348059847375297761006336024476146551185903\n        ],\n        [\n            10710998507064742997612080847223278109404482930427999113323732519626499166548,\n            14958094513415797513745395709487730603918953350067504982704138489305723550923,\n            24096319595904213497633343966229498735553590589105811393277073274927955202995\n        ],\n        [\n            17983724131200292654039765185049138356840415443160477259330748730019147254309,\n            17598096800487588874709548646068838880468456205252324677357706597166777506441,\n            27420647821110229619898200875848631488422182349567475956209153112306555222281\n        ],\n        [\n            448538544835457571662601142415301047108854812427100562339376187510452313026,\n            23494184556634922103535803143214434479598067155171780264810485708203176455201,\n            22626342941879801989161990529511235538216563009907378573817996229389756621777\n        ],\n        [\n            26128268137723417163973860961686381960826033145738852158792607959175787222856,\n            20225791828042873305317281581105429726352058325970107209484198122707862156597,\n            7538871133759632802857159609785118198934349221046986784429069814655215585732\n        ],\n        [\n            26184554861259642274153262777073624024579929401668865520166966302070394487366,\n            28755259264665180745537307265993667261709206143628938749669440804401623257679,\n            11896066093033549470312328497237649508068258723531931099214795928200015717321\n        ],\n        [\n            21657721599978732693249012287058163532690942515202465984736373311077240614059,\n            9214914097169852704753116653702415951907628005986883140609006971322091003693,\n            18710111680849814325169297240208687402588261569152088592693815711857504371037\n        ],\n        [\n            6813635166770764528979084175325709935892248249948967889926276426090222296643,\n            20546585456429436268067726231902751119458200511988152296570567167520382569278,\n            20087466019194902429054761607398988292568594301671509779549344754172952693871\n        ],\n        [\n            28185105286740691904534067831357491310995891986363455251895371651360605333143,\n            10108348212894231193041286244259038275269464277821588425688314560368589986063,\n            11433633215392393209829215018579238412423821563056156785641278458497271271546\n        ],\n        [\n            27870881917195016999862550657996865268956893566432995492427618003637597051321,\n            102309803677783876701097881491240456320211833502658383473112057006867019389,\n            22844040227595875612525628393174357057929113317578127744718774517498324646590\n        ],\n        [\n            18364790233947478619325319418813215212267974311771564959136180502266118026133,\n            2480624341921718230432383518425561514824501138863702825916674641657321180841,\n            16778939567530361665956758171503829349658551798564323167725356065198936433124\n        ],\n        [\n            11947564511486966895926950599696532964589539443187518177489990556481125699966,\n            3133187646540385483015602955087323554103587039123577645562801570574691666057,\n            27704797101265438206569218421707753788081674727344603874614391656565567951541\n        ],\n        [\n            13001484695584753475562184349533365512515447041450030471627087395341039487710,\n            477322000667279478600757543806155989948171541982639893984064422067850617496,\n            13913755821658634147813329813115566967428755223601185963529801459396673113438\n        ],\n        [\n            16621869429023470107454028095846067937827722393398508604914831452950874033411,\n            21755744236927410239079501831014076529931327263341620300431356747367343619046,\n            26538666591151124505694487799121414506088199961481579132019627484065014831180\n        ],\n        [\n            3066480818457008068617042549071052338581291837882909165666223566402713429090,\n            16182268213934119294035309949459684472027705439038023775276926916166831108357,\n            28907604876608422892474268478706783033050951245339691569015166507728369585190\n        ],\n        [\n            27973960109508292680965426133498827831691369851701664449575719912259359998113,\n            1456924360278399121996742356757866616312146358469991014696110099534285524446,\n            8234248752911525485438611255163504976087091103090603316695312869292347668495\n        ],\n        [\n            8716078950082339630026654067608811496722305720644485560320987802533380421009,\n            19016744645809919602099479306503354923553336014593353020688463619133130053825,\n            24379650661051444982012238084495990858827340608012118841005379796362233056432\n        ],\n        [\n            2245379544097631382062919677963998259142792890502492881341386639439507471783,\n            28788137434161061988371619554419440748189388934884757179010092973102292086583,\n            7187000185648741287953633167647835668543536354944774631102766873251849991238\n        ],\n        [\n            18319349500538500800225762827448369057030532278398270164660609327776487168142,\n            2622932985948021877314529887962683530522545893985767148345336304947201715671,\n            13805188629797792210337544360632964855143280581052079479249966961215582531026\n        ],\n        [\n            27457600993464082637917106210690168172469473943609357897393615707457194410878,\n            15448646156961779103834447043970817898237835202826003934642165760908058355399,\n            9396792545729486882231669677795667529746274932273033601723318032992363022062\n        ],\n        [\n            9927877141952679457141759789181418464292082444806533413864151258248124544859,\n            23827901395971835838179844085051957393677906360196119690926757794561937573142,\n            3273544693673216914876067527455588276979859627093391584406340272737391174619\n        ],\n        [\n            19571510438350300564152393820251652609646082150148656806391655428002614034315,\n            4458840243585913642400750597703353770666314833058197517675446022682775625834,\n            6452218213610300363069953741424106105609715382419342511693148495219793324457\n        ],\n        [\n            14558167930891460678441266912176752652821641543245953113671886345167213541771,\n            10650967986920075561478528461783351160938460620955779955379459848889204404950,\n            19990009778942542934049216419052172134625404062770188357110708518621145688588\n        ],\n        [\n            26855242974447190235826233682457047761532515293146087151296725996543442567035,\n            22785340043356532865086769889360674409753343398766563441587096485751538658065,\n            28603049427449348335651629195385434188071937908693764500052489540779792538285\n        ],\n        [\n            20545812864989828913452616721240947168977365844984763819184465128164378967167,\n            23234068381345797209897730226956922073109641728569353961504167817770340037954,\n            26031714567641615877877111172701145299483019910006153132858512509897185854695\n        ],\n        [\n            9512221744061419790435674197238913998387834650389922233458121639503195504983,\n            12587458000103271975978240683793268604398305885278203470492658961734100340536,\n            9670291694005369437277651504604785512303147991710650505302465204429311229197\n        ],\n        [\n            26995526763045548800439747262386290359229145489609341602564040676717570935439,\n            23742712112104280264401317024221734961713400615669958343926511931219510484675,\n            27931469778579449247589315744656633392873808631802461175539563849884447358271\n        ],\n        [\n            20669006894143187877081688942720159738269397552445286314270368345994751825389,\n            26891772301075275370472640177651637211280740381619976926886106618375467277414,\n            28387986011980449959047232529988203397251084614417760995257355718700961696092\n        ],\n        [\n            6579105010484741592730389416372694666279917604793318157514380025250233913402,\n            11007035767869292700964744408562802781669930023548892567535397874932420229930,\n            981148366863906885900456473323410468923514528856216824044152942069412627408\n        ],\n        [\n            22213671088722307302576907504985884923571642958053627659840326928319445671280,\n            1318836216310789598614608105109389429335273432455224127576823891011367206122,\n            25586582796990779718352441955439394949194222626688223867952982491529809559257\n        ],\n        [\n            4923739488579452777913681531125585976446366144127161879759262506690369040090,\n            23505612338866210737103599484620591026802005128655081877133994175016351514827,\n            323887003859465324514901860965142186539600668250760639664361851354147799637\n        ],\n        [\n            10198923064967306784017949469108033682156920551672348936591491217255268794658,\n            9593680688139131432883442351722730169325112619984238956948153423155998917175,\n            27027988263960602112273050725720071355535922812577299127302015348825197871870\n        ],\n        [\n            14419883951157390867695097127684346981136020111885301573583640959136319507752,\n            5104414988075833278683649298543440897371415916271358703850262680431809374355,\n            24739655595299332818980677669648719986462429574612913501586844601377825836782\n        ],\n        [\n            28522818684103966731129743408029731246564480741348128436668680764518115102581,\n            21520350704208288978690888796633940487888044365108767319141211249242880355961,\n            17391005598311948834360476853940353239444383292422171321575043660157438608537\n        ],\n        [\n            15367833944125677011173327826570204350687925236257190051755087781855930646142,\n            21715073802090413714601069529558707101797361591183718695054701329871284436172,\n            8994093285353831008525761670339342200997965950202092028313103110478252647618\n        ],\n        [\n            8370824693889782161629525898408725452177580012023459750897244954935682978671,\n            16123253540853556024347150096993154278773652905830608614979368087152152043083,\n            3535380953353495025888433493640531836449699255364366295870140701379497967423\n        ],\n        [\n            6954518484798178646508803478426114267143074508396663899281411171704702743829,\n            28903134801897070276701950388422104654018369750191967384271618837091859516942,\n            20872505363530172448468374920196608937030884647150175861507911076568784054834\n        ],\n        [\n            6902861581703501105786795670676641959401710346423594578401934671029571262513,\n            10124161387604183369443890585742198433184078889862870469507328332805848271064,\n            10488004060799269337071647841224034919633445750252076195310163972966405029030\n        ],\n        [\n            507704911991278613147490289466075160618843900088471236546244459176211783848,\n            7252739745607302667257774481690407709040936359589867974787811552896597703097,\n            23278073497974004442836030100920157527910770509761505828038443336325476654930\n        ],\n        [\n            22766285055433137793164317120096790621982728188995759745859222009100808389090,\n            23129058299483468195787339200845749049960038336751758017949899311636830205152,\n            16665333681978951552434356320651834889869437822496200946959897681307959400425\n        ],\n        [\n            12145699202182574939376505075528461451757079041659894988784442097333218352048,\n            26340666275844437932755852805027863696219004039301187587209926587657008948704,\n            19208771804191839410002226941825269105677187954811130189835856228258013753206\n        ],\n        [\n            21957102494792377508237608216278079874536155315851198461024084071231867104453,\n            6933367436450995525851693784691226222726503560893470094614235356287049091852,\n            15707767379191450768747057313641112321773921923533732633534831270357733757271\n        ],\n        [\n            27661963645951389261638591385668507557739541354225916772550248746235106571003,\n            19699458096897937575096494582288688995241392471402204995195057374756282223421,\n            902873385171181344315871113842580653512118892800584003934454469411716098791\n        ],\n        [\n            17184835876565576154014372215369798779520343573944211203710896053325717110660,\n            664657295519303589036289440053175741110032988007278988577620229144220576240,\n            10803972669668998371638869508774217165881281885838503958226056357738500321396\n        ],\n        [\n            2329846733754251453632375727999372856194157027336139087170310553870624325301,\n            14139944357035048486675740400655356660678187875721949218090128899571575479791,\n            18368148273419807418427674359327442879484531833435081951870369910704734685351\n        ],\n        [\n            10480273665080572189328459165704340191901489646067580012574464138528963201459,\n            21773636700078124500346009061678153597323236568110076029811348966753228682835,\n            18184268307211429260956076021417309535471438696101133218049142374847151474905\n        ],\n        [\n            25957533025669311312382992376854735734491934602484112256289764602447226406852,\n            22223261506176684934865714490719116745135417403915426392159449667435294570739,\n            22937309162832499167063076416585504361695925730111272512450449042837586253575\n        ],\n        [\n            16956181785481598286719868503945127919581091625126206673934113115358441284347,\n            8497782777197814773596870810881707148695901557289856910220737358078100998191,\n            21135503731586600979470064722475007625236017670426339278983640892218291297054\n        ],\n        [\n            17809297343844488723046665739910571149089769215421130894378638450427880983923,\n            72435395972188389387093550708873189001876361107443937983754878061522372356,\n            7511239878692099209014947248389283109997289411550315391143819429585903287870\n        ]\n    ];\n}\n"
    },
    "contracts/legacy/PallasCurveLegacy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../PallasTypes.sol\";\n\n/**\n * @title PallasCurve\n * @dev Implementation of Pallas curve operations\n */\ncontract PallasCurveLegacy is PallasTypes {\n    /// @notice Field modulus for Pallas curve\n    uint256 public constant FIELD_MODULUS =\n        0x40000000000000000000000000000000224698fc094cf91b992d30ed00000001;\n\n    /// @notice Scalar field modulus for Pallas curve\n    uint256 public constant SCALAR_MODULUS =\n        0x40000000000000000000000000224698fc0994a8dd8c46eb2100000001;\n\n    /// @notice Curve equation constant (B) where y² = x³ + B\n    uint256 public constant BEQ = 5;\n\n    /// @notice Default signature prefix for testnet\n    string public constant SIGNATURE_PREFIX = \"CodaSignature*******\";\n\n    /// @notice Signature prefix for mainnet\n    string public constant MAINNET_SIGNATURE_PREFIX = \"MinaSignatureMainnet\";\n\n    /// @notice Default length for string operations\n    uint256 public constant DEFAULT_STRING_LENGTH = 128;\n\n    /// @notice Generator point x-coordinate\n    uint256 public constant G_X = 1;\n\n    /// @notice Generator point y-coordinate\n    uint256 public constant G_Y =\n        0x1b74b5a30a12937c53dfa9f06378ee548f655bd4333d477119cf7a23caed2abb;\n\n    /// @notice Performs modular addition\n    /// @dev Wrapper around Solidity's addmod\n    /// @param x First operand\n    /// @param y Second operand\n    /// @param k Modulus\n    /// @return uint256 Result of (x + y) mod k\n    function add(uint x, uint y, uint k) internal pure returns (uint256) {\n        return addmod(x, y, k);\n    }\n\n    /// @notice Performs modular multiplication\n    /// @dev Wrapper around Solidity's mulmod\n    /// @param x First operand\n    /// @param y Second operand\n    /// @param k Modulus\n    /// @return uint256 Result of (x * y) mod k\n    function mul(uint x, uint y, uint k) internal pure returns (uint256) {\n        return mulmod(x, y, k);\n    }\n\n    /// @notice Computes modular multiplicative inverse\n    /// @dev Implements extended Euclidean algorithm\n    /// @param a Value to invert\n    /// @return uint256 Modular multiplicative inverse of a\n    function invmod(uint256 a) internal pure returns (uint256) {\n        if (a == 0) revert(\"Cannot invert 0\");\n\n        uint256 t = 0;\n        uint256 newt = 1;\n        uint256 r = FIELD_MODULUS;\n        uint256 newr = a;\n        uint256 quotient;\n        uint256 temp;\n\n        unchecked {\n            while (newr != 0) {\n                quotient = r / newr;\n\n                temp = t;\n                t = newt;\n                newt = temp - quotient * newt;\n\n                temp = r;\n                r = newr;\n                newr = temp - quotient * newr;\n            }\n\n            if (t > FIELD_MODULUS) {\n                t += FIELD_MODULUS;\n            }\n        }\n        return t;\n    }\n\n    /// @notice Performs modular exponentiation\n    /// @dev Uses precompiled contract at address 0x05\n    /// @param base Base value\n    /// @param exponent Exponent value\n    /// @param modulus Modulus for operation\n    /// @return result Result of base^exponent mod modulus\n    function modExp(\n        uint256 base,\n        uint256 exponent,\n        uint256 modulus\n    ) internal view returns (uint256 result) {\n        assembly {\n            // Free memory pointer\n            let p := mload(0x40)\n\n            // Store length of base, exponent and modulus\n            mstore(p, 0x20)\n            mstore(add(p, 0x20), 0x20)\n            mstore(add(p, 0x40), 0x20)\n\n            // Store base, exponent and modulus\n            mstore(add(p, 0x60), base)\n            mstore(add(p, 0x80), exponent)\n            mstore(add(p, 0xa0), modulus)\n\n            // Call precompiled contract for modular exponentiation\n            if iszero(staticcall(gas(), 0x05, p, 0xc0, p, 0x20)) {\n                revert(0, 0)\n            }\n\n            result := mload(p)\n        }\n    }\n\n    /// @notice Computes modular square root using Tonelli-Shanks algorithm\n    /// @dev Implements for prime modulus\n    /// @param n Value to find square root of\n    /// @param p Modulus (must be prime)\n    /// @return uint256 Modular square root of n\n    function sqrtmod(uint256 n, uint256 p) internal view returns (uint256) {\n        if (n == 0) return 0;\n\n        // Calculate Q and M where p - 1 = Q * 2^M and Q is odd\n        uint256 Q = p - 1;\n        uint256 M = 0;\n        while (Q % 2 == 0) {\n            Q /= 2;\n            M++;\n        }\n\n        // Find a non-residue z\n        uint256 z = 2;\n        while (true) {\n            if (modExp(z, (p - 1) / 2, p) == p - 1) break; // Found a non-residue\n            z++;\n        }\n\n        uint256 c = modExp(z, Q, p);\n        uint256 t = modExp(n, Q >> 1, p); // n^((Q-1)/2)\n        uint256 R = mulmod(t, n, p); // n^((Q+1)/2)\n        t = mulmod(t, R, p); // n^Q\n\n        while (t != 1) {\n            uint256 i = 0;\n            uint256 s = t;\n            while (s != 1 && i < M) {\n                s = mulmod(s, s, p);\n                i++;\n            }\n            require(i < M, \"Square root does not exist\");\n\n            uint256 b = c;\n            for (uint256 j = 0; j < M - i - 1; j++) {\n                b = mulmod(b, b, p);\n            }\n            M = i;\n            c = mulmod(b, b, p);\n            t = mulmod(t, c, p);\n            R = mulmod(R, b, p);\n        }\n\n        return R;\n    }\n\n    /// @notice Checks if a number is even\n    /// @dev Uses bitwise AND operation\n    /// @param x Number to check\n    /// @return bool True if number is even\n    function isEven(uint256 x) internal pure returns (bool) {\n        return (x & 1) == 0;\n    }\n\n    /// @notice Verifies if a point lies on the Pallas curve\n    /// @dev Checks if point satisfies y² = x³ + 5\n    /// @param p Point to check\n    /// @return bool True if point is on curve\n    function isOnCurve(Point memory p) internal pure returns (bool) {\n        if (p.x >= FIELD_MODULUS || p.y >= FIELD_MODULUS) {\n            return false;\n        }\n\n        uint256 lhs = mulmod(p.y, p.y, FIELD_MODULUS);\n        uint256 x2 = mulmod(p.x, p.x, FIELD_MODULUS);\n        uint256 x3 = mulmod(x2, p.x, FIELD_MODULUS);\n        uint256 rhs = addmod(x3, BEQ, FIELD_MODULUS);\n\n        return lhs == rhs;\n    }\n\n    /// @notice Converts a point from affine to projective coordinates\n    /// @dev Returns (1:1:0) for point at infinity\n    /// @param p Point in affine coordinates\n    /// @return ProjectivePoint Point in projective coordinates\n    function toProjective(\n        Point memory p\n    ) internal pure returns (ProjectivePoint memory) {\n        if (p.x == 0 && p.y == 0) {\n            return ProjectivePoint(1, 1, 0); // Point at infinity\n        }\n        return ProjectivePoint(p.x, p.y, 1);\n    }\n\n    /// @notice Converts a point from projective to affine coordinates\n    /// @dev Handles point at infinity case\n    /// @param p Point in projective coordinates\n    /// @return Point Point in affine coordinates\n    function toAffine(\n        ProjectivePoint memory p\n    ) internal pure returns (Point memory) {\n        if (p.z == 0) {\n            return Point(0, 0); // Point at infinity\n        }\n\n        uint256 zinv = invmod(p.z);\n        uint256 zinv_squared = mulmod(zinv, zinv, FIELD_MODULUS);\n\n        return\n            Point(\n                mulmod(p.x, zinv_squared, FIELD_MODULUS),\n                mulmod(\n                    p.y,\n                    mulmod(zinv, zinv_squared, FIELD_MODULUS),\n                    FIELD_MODULUS\n                )\n            );\n    }\n\n    /// @notice Doubles a point in projective coordinates\n    /// @dev Specialized operation for when both points are the same\n    /// @param g Point to double\n    /// @return ProjectivePoint Doubled point\n    function projectiveDouble(\n        ProjectivePoint memory g\n    ) internal pure returns (ProjectivePoint memory) {\n        if (g.z == 0) return g;\n        if (g.y == 0) revert(\"Cannot double point with y=0\");\n\n        unchecked {\n            // Cache x, y, z values\n            uint256 x = g.x;\n            uint256 y = g.y;\n            uint256 z = g.z;\n\n            // A = X1^2\n            uint256 A = mulmod(x, x, FIELD_MODULUS);\n            // B = Y1^2\n            uint256 B = mulmod(y, y, FIELD_MODULUS);\n            // C = B^2\n            uint256 C = mulmod(B, B, FIELD_MODULUS);\n\n            // Cache X1+B\n            uint256 xPlusB = addmod(x, B, FIELD_MODULUS);\n            // D = 2*((X1+B)^2-A-C)\n            uint256 D = mulmod(\n                2,\n                addmod(\n                    mulmod(xPlusB, xPlusB, FIELD_MODULUS),\n                    FIELD_MODULUS - addmod(A, C, FIELD_MODULUS),\n                    FIELD_MODULUS\n                ),\n                FIELD_MODULUS\n            );\n\n            // E = 3*A\n            uint256 E = mulmod(3, A, FIELD_MODULUS);\n            // F = E^2\n            uint256 F = mulmod(E, E, FIELD_MODULUS);\n\n            // Calculate X3 first as it's needed for Y3\n            uint256 X3 = addmod(\n                F,\n                FIELD_MODULUS - mulmod(2, D, FIELD_MODULUS),\n                FIELD_MODULUS\n            );\n\n            return\n                ProjectivePoint(\n                    X3,\n                    addmod(\n                        mulmod(\n                            E,\n                            addmod(D, FIELD_MODULUS - X3, FIELD_MODULUS),\n                            FIELD_MODULUS\n                        ),\n                        FIELD_MODULUS - mulmod(8, C, FIELD_MODULUS),\n                        FIELD_MODULUS\n                    ),\n                    mulmod(2, mulmod(y, z, FIELD_MODULUS), FIELD_MODULUS)\n                );\n        }\n    }\n\n    /// @notice Adds two points in projective coordinates\n    /// @dev Complete addition formula for Pallas curve\n    /// @param g First point\n    /// @param h Second point\n    /// @return ProjectivePoint Resulting point\n    function projectiveAdd(\n        ProjectivePoint memory g,\n        ProjectivePoint memory h\n    ) internal pure returns (ProjectivePoint memory) {\n        if (g.z == 0) return h;\n        if (h.z == 0) return g;\n\n        unchecked {\n            uint256 z1 = g.z;\n            uint256 z2 = h.z;\n\n            uint256 Z1Z1 = mulmod(z1, z1, FIELD_MODULUS);\n            uint256 Z2Z2 = mulmod(z2, z2, FIELD_MODULUS);\n            uint256 U1 = mulmod(g.x, Z2Z2, FIELD_MODULUS);\n            uint256 U2 = mulmod(h.x, Z1Z1, FIELD_MODULUS);\n            uint256 S1 = mulmod(\n                g.y,\n                mulmod(z2, Z2Z2, FIELD_MODULUS),\n                FIELD_MODULUS\n            );\n            uint256 S2 = mulmod(\n                h.y,\n                mulmod(z1, Z1Z1, FIELD_MODULUS),\n                FIELD_MODULUS\n            );\n            uint256 H = addmod(U2, FIELD_MODULUS - U1, FIELD_MODULUS);\n\n            if (H == 0) {\n                if (S1 == S2) {\n                    return projectiveDouble(g);\n                }\n                if (addmod(S1, S2, FIELD_MODULUS) == 0) {\n                    return ProjectivePoint(1, 1, 0);\n                }\n                revert(\"Invalid point addition\");\n            }\n\n            uint256 I = mulmod(mulmod(H, H, FIELD_MODULUS), 4, FIELD_MODULUS);\n            uint256 J = mulmod(H, I, FIELD_MODULUS);\n            uint256 r = mulmod(\n                2,\n                addmod(S2, FIELD_MODULUS - S1, FIELD_MODULUS),\n                FIELD_MODULUS\n            );\n            uint256 V = mulmod(U1, I, FIELD_MODULUS);\n\n            // Calculate X3 first as it's needed for Y3\n            uint256 X3 = addmod(\n                mulmod(r, r, FIELD_MODULUS),\n                FIELD_MODULUS -\n                    addmod(J, mulmod(2, V, FIELD_MODULUS), FIELD_MODULUS),\n                FIELD_MODULUS\n            );\n\n            return\n                ProjectivePoint(\n                    X3,\n                    addmod(\n                        mulmod(\n                            r,\n                            addmod(V, FIELD_MODULUS - X3, FIELD_MODULUS),\n                            FIELD_MODULUS\n                        ),\n                        FIELD_MODULUS -\n                            mulmod(\n                                2,\n                                mulmod(S1, J, FIELD_MODULUS),\n                                FIELD_MODULUS\n                            ),\n                        FIELD_MODULUS\n                    ),\n                    mulmod(\n                        addmod(\n                            mulmod(\n                                addmod(z1, z2, FIELD_MODULUS),\n                                addmod(z1, z2, FIELD_MODULUS),\n                                FIELD_MODULUS\n                            ),\n                            FIELD_MODULUS - addmod(Z1Z1, Z2Z2, FIELD_MODULUS),\n                            FIELD_MODULUS\n                        ),\n                        H,\n                        FIELD_MODULUS\n                    )\n                );\n        }\n    }\n\n    /// @notice Adds two points in affine coordinates\n    /// @dev Converts to projective, adds, then converts back\n    /// @param p1 First point\n    /// @param p2 Second point\n    /// @return Point Sum of the points\n    function addPoints(\n        Point memory p1,\n        Point memory p2\n    ) internal pure returns (Point memory) {\n        ProjectivePoint memory g = toProjective(p1);\n        ProjectivePoint memory h = toProjective(p2);\n        ProjectivePoint memory r = projectiveAdd(g, h);\n        return toAffine(r);\n    }\n\n    /// @notice Performs scalar multiplication\n    /// @dev Uses double-and-add algorithm\n    /// @param p Base point\n    /// @param scalar Scalar value\n    /// @return Point Resulting point\n    function scalarMul(\n        Point memory p,\n        uint256 scalar\n    ) internal pure returns (Point memory) {\n        ProjectivePoint memory g = toProjective(p);\n        ProjectivePoint memory result = ProjectivePoint(1, 1, 0);\n        ProjectivePoint memory current = g;\n\n        // scalar = scalar % SCALAR_MODULUS;\n        while (scalar > 0) {\n            if (scalar & 1 == 1) {\n                result = projectiveAdd(result, current);\n            }\n            current = projectiveDouble(current);\n            scalar >>= 1;\n        }\n\n        return toAffine(result);\n    }\n}\n"
    },
    "contracts/legacy/PoseidonLegacy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./PallasConstantsLegacy.sol\";\nimport \"./PallasCurveLegacy.sol\";\nimport \"hardhat/console.sol\";\n\n/**\n * @title PoseidonLegacy\n * @dev Implementation of Poseidon hash function for t = 3 (2 inputs)\n */\n\ncontract PoseidonLegacy is PallasCurveLegacy, PallasConstantsLegacy {\n    uint256 internal constant BITS_PER_FIELD = 254;\n    uint256 internal constant CODA_PREFIX_FIELD =\n        240717916736854602989207148466022993262069182275;\n    uint256 internal constant MINA_PREFIX_FIELD =\n        664504924603203994814403132056773144791042910541;\n\n    struct HashInputLegacy {\n        uint256[] fields;\n        bool[] bits;\n    }\n\n    /// @notice Computes x^5 mod FIELD_MODULUS\n    /// @dev Optimized power5 implementation using square-and-multiply\n    /// @param x Base value\n    /// @return uint256 Result of x^5\n    function power5(uint256 x) internal pure returns (uint256) {\n        uint256 x2 = mulmod(x, x, FIELD_MODULUS);\n        uint256 x4 = mulmod(x2, x2, FIELD_MODULUS);\n        return mulmod(x4, x, FIELD_MODULUS);\n    }\n\n    /// @notice Initial state array [0, 0, 0]\n    /// @dev Creates starting state for Poseidon hash\n    /// @return uint256[3] Initial state array\n    function initialState() internal pure returns (uint256[3] memory) {\n        return [uint256(0), uint256(0), uint256(0)];\n    }\n\n    /// @notice Retrieves value from MDS matrix at specified position\n    /// @dev Used in the Poseidon permutation\n    /// @param row Row index\n    /// @param col Column index\n    /// @return uint256 Matrix value at position\n    function getMdsValue(\n        uint256 row,\n        uint256 col\n    ) internal view returns (uint256) {\n        require(row < 3 && col < 3, \"Invalid MDS indices\");\n        return mdsMatrix[row][col];\n    }\n\n    /// @notice Gets round constant for specified round and position\n    /// @dev Access round constants array with bounds checking\n    /// @param round Round number\n    /// @param pos Position in the round\n    /// @return uint256 Round constant value\n    function getRoundConstant(\n        uint256 round,\n        uint256 pos\n    ) internal view returns (uint256) {\n        require(\n            round < (POSEIDON_FULL_ROUNDS + 1) && pos < 3, // +1 for initial round constant\n            \"Invalid round constant indices\"\n        );\n        return roundConstants[round][pos];\n    }\n\n    /// @notice Performs matrix multiplication with MDS matrix\n    /// @dev Core operation in Poseidon permutation\n    /// @param state Current state array\n    /// @return result Result of matrix multiplication\n    function mdsMultiply(\n        uint256[3] memory state\n    ) internal view returns (uint256[3] memory result) {\n        // Unroll the loops for gas efficiency\n        result[0] = addmod(\n            addmod(\n                mulmod(getMdsValue(0, 0), state[0], FIELD_MODULUS),\n                mulmod(getMdsValue(0, 1), state[1], FIELD_MODULUS),\n                FIELD_MODULUS\n            ),\n            mulmod(getMdsValue(0, 2), state[2], FIELD_MODULUS),\n            FIELD_MODULUS\n        );\n\n        result[1] = addmod(\n            addmod(\n                mulmod(getMdsValue(1, 0), state[0], FIELD_MODULUS),\n                mulmod(getMdsValue(1, 1), state[1], FIELD_MODULUS),\n                FIELD_MODULUS\n            ),\n            mulmod(getMdsValue(1, 2), state[2], FIELD_MODULUS),\n            FIELD_MODULUS\n        );\n\n        result[2] = addmod(\n            addmod(\n                mulmod(getMdsValue(2, 0), state[0], FIELD_MODULUS),\n                mulmod(getMdsValue(2, 1), state[1], FIELD_MODULUS),\n                FIELD_MODULUS\n            ),\n            mulmod(getMdsValue(2, 2), state[2], FIELD_MODULUS),\n            FIELD_MODULUS\n        );\n    }\n\n    /// @notice Performs the Poseidon permutation\n    /// @dev Main cryptographic operation including rounds of substitution and diffusion\n    /// @param state Input state array\n    /// @return uint256[3] Permuted state\n    function poseidonPermutation(\n        uint256[3] memory state\n    ) internal view returns (uint256[3] memory) {\n        uint256 offset = 0;\n\n        if (POSEIDON_HAS_INITIAL_ROUND_CONSTANT) {\n            state[0] = addmod(state[0], roundConstants[0][0], FIELD_MODULUS);\n            state[1] = addmod(state[1], roundConstants[0][1], FIELD_MODULUS);\n            state[2] = addmod(state[2], roundConstants[0][2], FIELD_MODULUS);\n            offset = 1;\n        }\n\n        for (uint256 round = 0; round < POSEIDON_FULL_ROUNDS; round++) {\n            state[0] = power5(state[0]);\n            state[1] = power5(state[1]);\n            state[2] = power5(state[2]);\n\n            state = mdsMultiply(state);\n\n            state[0] = addmod(\n                state[0],\n                getRoundConstant(round + offset, 0),\n                FIELD_MODULUS\n            );\n            state[1] = addmod(\n                state[1],\n                getRoundConstant(round + offset, 1),\n                FIELD_MODULUS\n            );\n            state[2] = addmod(\n                state[2],\n                getRoundConstant(round + offset, 2),\n                FIELD_MODULUS\n            );\n        }\n\n        return state;\n    }\n\n    /// @notice Updates hash state with input\n    /// @dev Processes input in rate-sized blocks\n    /// @param state Current state\n    /// @param input Input values\n    /// @return uint256[3] Updated state\n    function update(\n        uint256[3] memory state,\n        uint256[] memory input\n    ) internal view returns (uint256[3] memory) {\n        if (input.length == 0) {\n            return poseidonPermutation(state);\n        }\n\n        uint256 n = ((input.length + POSEIDON_RATE - 1) / POSEIDON_RATE) *\n            POSEIDON_RATE;\n        uint256[] memory paddedInput = new uint256[](n);\n        for (uint256 i = 0; i < input.length; i++) {\n            paddedInput[i] = input[i];\n        }\n\n        for (\n            uint256 blockIndex = 0;\n            blockIndex < n;\n            blockIndex += POSEIDON_RATE\n        ) {\n            state[0] = addmod(state[0], paddedInput[blockIndex], FIELD_MODULUS);\n            if (blockIndex + 1 < n) {\n                state[1] = addmod(\n                    state[1],\n                    paddedInput[blockIndex + 1],\n                    FIELD_MODULUS\n                );\n            }\n            state = poseidonPermutation(state);\n        }\n        return state;\n    }\n\n    /// @notice Converts string to array of bits\n    /// @dev Matches o1js bit ordering\n    /// @param str Input string\n    /// @return bool[] Array of bits\n    function stringToBits(\n        string memory str\n    ) internal pure returns (bool[] memory) {\n        bytes memory strBytes = bytes(str);\n        bool[] memory bits = new bool[](strBytes.length * 8);\n\n        for (uint i = 0; i < strBytes.length; i++) {\n            uint8 b = uint8(strBytes[i]);\n            for (uint j = 0; j < 8; j++) {\n                bits[i * 8 + j] = (b & (1 << (7 - j))) != 0;\n            }\n        }\n        return bits;\n    }\n\n    /// @notice Converts bits to bytes\n    /// @dev Used in field element conversion\n    /// @param bits Array of bits\n    /// @return bytes Resulting byte array\n    function bitsToBytes(\n        bool[] memory bits\n    ) internal pure returns (bytes memory) {\n        uint256 numBytes = (bits.length + 7) / 8;\n        bytes memory result = new bytes(numBytes);\n\n        for (uint256 i = 0; i < numBytes; i++) {\n            uint8 byteVal = 0;\n            for (uint8 bit = 0; bit < 8; bit++) {\n                uint256 bitIndex = i * 8 + bit;\n                if (bitIndex < bits.length && bits[bitIndex]) {\n                    byteVal |= uint8(1 << bit);\n                }\n            }\n            result[i] = bytes1(byteVal);\n        }\n        return result;\n    }\n\n    /// @notice Converts bytes to field element\n    /// @dev Reduces result modulo FIELD_MODULUS\n    /// @param b Input bytes\n    /// @return uint256 Field element\n    function bytesToFieldElement(\n        bytes memory b\n    ) internal pure returns (uint256) {\n        uint256 result = 0;\n        for (uint256 i = 0; i < b.length; i++) {\n            result += uint256(uint8(b[i])) << (i * 8);\n        }\n        return result % FIELD_MODULUS;\n    }\n\n    /// @notice Converts prefix string to field element\n    /// @dev Uses little-endian byte ordering\n    /// @param prefix Input string\n    /// @return uint256 Field element\n    function prefixToField(\n        string memory prefix\n    ) internal pure returns (uint256) {\n        bytes memory prefixBytes = bytes(prefix);\n        require(prefixBytes.length < 32, \"prefix too long\");\n\n        uint256 result = 0;\n        // Process in little-endian order (like o1js)\n        for (uint i = 0; i < 32; i++) {\n            if (i < prefixBytes.length) {\n                result |= uint256(uint8(prefixBytes[i])) << (i * 8);\n            }\n        }\n\n        return result % FIELD_MODULUS;\n    }\n\n    /// @notice Packs HashInputLegacy into array of field elements\n    /// @dev Handles both field and bit inputs\n    /// @param input HashInputLegacy struct\n    /// @return uint256[] Array of packed field elements\n    function packToFieldsLegacy(\n        HashInputLegacy memory input\n    ) internal pure returns (uint256[] memory) {\n        uint256 numBitFields = (input.bits.length + BITS_PER_FIELD - 1) /\n            BITS_PER_FIELD;\n        uint256[] memory result = new uint256[](\n            input.fields.length + numBitFields\n        );\n\n        for (uint256 i = 0; i < input.fields.length; i++) {\n            result[i] = input.fields[i];\n        }\n\n        uint256 bitsProcessed = 0;\n        for (uint256 i = 0; i < numBitFields; i++) {\n            uint256 bitsToTake = bitsProcessed + BITS_PER_FIELD >\n                input.bits.length\n                ? input.bits.length - bitsProcessed\n                : BITS_PER_FIELD;\n\n            bool[] memory fieldBits = new bool[](BITS_PER_FIELD);\n            for (uint256 j = 0; j < bitsToTake; j++) {\n                fieldBits[j] = input.bits[bitsProcessed + j];\n            }\n\n            bytes memory fieldBytes = bitsToBytes(fieldBits);\n            result[input.fields.length + i] = bytesToFieldElement(fieldBytes);\n            bitsProcessed += bitsToTake;\n        }\n\n        return result;\n    }\n\n    /// @notice Combines two HashInputLegacy structs\n    /// @dev Concatenates both fields and bits arrays\n    /// @param input1 First input\n    /// @param input2 Second input\n    /// @return HashInputLegacy Combined input\n    function appendHashInputs(\n        HashInputLegacy memory input1,\n        HashInputLegacy memory input2\n    ) internal pure returns (HashInputLegacy memory) {\n        uint256[] memory combinedFields = new uint256[](\n            input1.fields.length + input2.fields.length\n        );\n        bool[] memory combinedBits = new bool[](\n            input1.bits.length + input2.bits.length\n        );\n\n        for (uint256 i = 0; i < input1.fields.length; i++) {\n            combinedFields[i] = input1.fields[i];\n        }\n        for (uint256 i = 0; i < input2.fields.length; i++) {\n            combinedFields[input1.fields.length + i] = input2.fields[i];\n        }\n\n        for (uint256 i = 0; i < input1.bits.length; i++) {\n            combinedBits[i] = input1.bits[i];\n        }\n        for (uint256 i = 0; i < input2.bits.length; i++) {\n            combinedBits[input1.bits.length + i] = input2.bits[i];\n        }\n\n        return HashInputLegacy({fields: combinedFields, bits: combinedBits});\n    }\n\n    // @notice Computes Poseidon hash of input array\n    /// @dev Main hashing function without prefix\n    /// @param input Array to hash\n    /// @return uint256 Hash result\n    function poseidonLegacyHash(\n        uint256[] memory input\n    ) public view returns (uint256) {\n        uint256[3] memory state = initialState();\n        state = update(state, input);\n\n        return state[0];\n    }\n\n    /// @notice Computes Poseidon hash with prefix\n    /// @dev Hashes prefix followed by input array\n    /// @param prefix String prefix\n    /// @param input Array to hash\n    /// @return uint256 Hash result\n    function poseidonLegacyHashWithPrefix(\n        string memory prefix,\n        uint256[] memory input\n    ) public view returns (uint256) {\n        // Start with initial state [0, 0, 0]\n        uint256[3] memory state = initialState();\n\n        // Create prefix array with single element\n        uint256[] memory prefixArray = new uint256[](1);\n        prefixArray[0] = prefixToField(prefix);\n\n        // First update with prefix\n        state = update(state, prefixArray);\n\n        // Then update with input\n        state = update(state, input);\n\n        return state[0];\n    }\n\n    /// @notice Hashes message with public key and signature data\n    /// @dev Complete message hashing matching o1js implementation\n    /// @param message String message\n    /// @param publicKey Public key point\n    /// @param r Signature r value\n    /// @param prefix Network prefix\n    /// @return uint256 Hash result\n    function hashMessageLegacy(\n        string memory message,\n        Point memory publicKey,\n        uint256 r,\n        string memory prefix\n    ) internal view returns (uint256) {\n        HashInputLegacy memory messageInput = HashInputLegacy({\n            fields: new uint256[](0),\n            bits: stringToBits(message)\n        });\n\n        uint256[] memory pkFields = new uint256[](3);\n        pkFields[0] = publicKey.x;\n        pkFields[1] = publicKey.y;\n        pkFields[2] = r;\n\n        HashInputLegacy memory pkInput = HashInputLegacy({\n            fields: pkFields,\n            bits: new bool[](0)\n        });\n\n        HashInputLegacy memory fullInput = appendHashInputs(\n            messageInput,\n            pkInput\n        );\n        uint256[] memory packedFields = packToFieldsLegacy(fullInput);\n\n        // Use cached prefix values\n        uint256 prefixField = keccak256(bytes(prefix)) ==\n            keccak256(bytes(\"MinaSignatureMainnet\"))\n            ? MINA_PREFIX_FIELD\n            : CODA_PREFIX_FIELD;\n\n        uint256[] memory prefixArray = new uint256[](1);\n        prefixArray[0] = prefixField;\n\n        uint256[3] memory state = initialState();\n        state = update(state, prefixArray);\n        state = update(state, packedFields);\n\n        return state[0];\n    }\n}\n"
    },
    "contracts/PallasTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title PallasTypes\n * @dev Common types used in Pallas operations\n */\ncontract PallasTypes {\n    /// @title Point Structure\n    /// @notice Represents a point on an elliptic curve with x and y coordinates\n    /// @dev Used for public key and signature operations\n    struct Point {\n        uint256 x;\n        uint256 y;\n    }\n\n    /// @title Compressed Point Structure\n    /// @notice Represents a compressed form of an elliptic curve point\n    /// @dev Uses x-coordinate and a boolean flag instead of full coordinates\n    struct PointCompressed {\n        uint256 x;\n        bool isOdd;\n    }\n\n    /// @title Digital Signature Structure\n    /// @notice Represents a digital signature with its components\n    /// @dev Used for cryptographic signature verification\n    struct Signature {\n        uint256 r;\n        uint256 s;\n    }\n\n    /// @title Projective Point Structure\n    /// @notice Represents a point in projective coordinates\n    /// @dev Used for efficient elliptic curve operations\n    struct ProjectivePoint {\n        uint256 x;\n        uint256 y;\n        uint256 z;\n    }\n\n    /// @title Verify Fields State Structure\n    /// @notice Holds the state for field array signature verification process\n    /// @dev Used to track the progress and store intermediate results during verification\n    struct VerifyFieldsState {\n        /// @notice Indicates if the state has been properly initialized\n        bool init;\n        /// @notice Network flag - true for mainnet, false for testnet\n        bool mainnet;\n        /// @notice Final verification result\n        bool isValid;\n        /// @notice Tracks the current step of verification (0-6)\n        uint8 atStep;\n        /// @notice The public key point (x,y) being verified against\n        Point publicKey;\n        /// @notice The signature containing r (x-coordinate) and s (scalar)\n        Signature signature;\n        /// @notice Hash of the fields array with prefix ('e' value)\n        uint256 messageHash;\n        /// @notice Public key converted to curve point format\n        Point pkInGroup;\n        /// @notice Result of scalar multiplication s*G\n        Point sG;\n        /// @notice Result of scalar multiplication e*pkInGroup\n        Point ePk;\n        /// @notice Final computed point R = sG - ePk\n        Point R;\n        /// @notice Network-specific prefix for message hashing\n        string prefix;\n        /// @notice Array of field elements to verify\n        uint256[] fields;\n    }\n\n    /// @title Verification Fields State Compressed Structure.\n    /// @notice Holds only the primary state for message signature verification process\n    struct VerifyFieldsStateCompressed {\n        /// @notice Indicates the type. 1 for Message, 2 for Fields. Helpful when reading\n        uint8 verifyType;\n        /// @notice The unique id\n        uint256 vfId;\n        /// @notice Network flag - true for mainnet, false for testnet\n        bool mainnet;\n        /// @notice Final verification result\n        bool isValid;\n        /// @notice The public key point (x,y) being verified against\n        Point publicKey;\n        /// @notice The signature containing r (x-coordinate) and s (scalar)\n        Signature signature;\n        /// @notice Hash of the fields array with prefix ('e' value)\n        uint256 messageHash;\n        /// @notice Network-specific prefix for message hashing\n        string prefix;\n        /// @notice Array of field elements to verify\n        uint256[] fields;\n    }\n\n    /// @title Verification Message State Structure\n    /// @notice Holds the state for message signature verification process\n    /// @dev Used to track the progress and store intermediate results during verification\n    struct VerifyMessageState {\n        /// @notice Indicates if the state has been properly initialized\n        bool init;\n        /// @notice Network flag - true for mainnet, false for testnet\n        bool mainnet;\n        /// @notice Final verification result\n        bool isValid;\n        /// @notice Tracks the current step of verification (0-6)\n        uint8 atStep;\n        /// @notice The public key point (x,y) being verified against\n        Point publicKey;\n        /// @notice The signature containing r (x-coordinate) and s (scalar)\n        Signature signature;\n        /// @notice Stores the computed hash of the message\n        uint256 messageHash;\n        /// @notice Public key converted to group form\n        Point pkInGroup;\n        /// @notice Result of scalar multiplication s*G\n        Point sG;\n        /// @notice Result of scalar multiplication e*pkInGroup\n        Point ePk;\n        /// @notice Final computed point R = sG - ePk\n        Point R;\n        /// @notice The message being verified\n        string message;\n        /// @notice Network-specific prefix for message hashing\n        string prefix;\n    }\n\n    /// @title Verification Message State Compressed Structure.\n    /// @notice Holds only the primary state for message signature verification process\n    struct VerifyMessageStateCompressed {\n        /// @notice Indicates the type. 1 for Message, 2 for Fields. Helpful when reading\n        uint8 verifyType;\n        /// @notice The unique id\n        uint256 vmId;\n        /// @notice Network flag - true for mainnet, false for testnet\n        bool mainnet;\n        /// @notice Final verification result\n        bool isValid;\n        /// @notice The public key point (x,y) being verified against\n        Point publicKey;\n        /// @notice The signature containing r (x-coordinate) and s (scalar)\n        Signature signature;\n        /// @notice Stores the computed hash of the message\n        uint256 messageHash;\n        /// @notice Network-specific prefix for message hashing\n        string prefix;\n        /// @notice The message being verified\n        string message;\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100000,
      "details": {
        "yul": true,
        "yulDetails": {
          "stackAllocation": true
        }
      }
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}